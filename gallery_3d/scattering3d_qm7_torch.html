
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>3D scattering quantum chemistry regression &#8212; kymatio 0.3.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-rendered-html.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../_static/kymatio.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="What’s New" href="../whats_new.html" />
    <link rel="prev" title="3D examples" href="index.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
    <link rel="apple-touch-icon" href="../_static/kymatio.jpg" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="sphx-glr-download-link-note admonition note">
<p class="admonition-title">Note</p>
<p>Click <a class="reference internal" href="#sphx-glr-download-gallery-3d-scattering3d-qm7-torch-py"><span class="std std-ref">here</span></a>
to download the full example code</p>
</div>
<section class="sphx-glr-example-title" id="d-scattering-quantum-chemistry-regression">
<span id="sphx-glr-gallery-3d-scattering3d-qm7-torch-py"></span><h1>3D scattering quantum chemistry regression<a class="headerlink" href="#d-scattering-quantum-chemistry-regression" title="Permalink to this heading">¶</a></h1>
<p>Description:
This example trains a classifier combined with a scattering transform to
regress molecular atomization energies on the QM7 dataset. Here, we use full
charges, valence charges and core charges. A linear regression is deployed.</p>
<p>Remarks:
The linear regression of the QM7 energies with the given values gives MAE
2.75, RMSE 4.18 (kcal.mol-1)</p>
<p>Reference:
<a class="reference external" href="https://arxiv.org/abs/1805.00571">https://arxiv.org/abs/1805.00571</a></p>
<section id="preliminaries">
<h2>Preliminaries<a class="headerlink" href="#preliminaries" title="Permalink to this heading">¶</a></h2>
<p>First, we import NumPy, PyTorch, and some utility modules.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">os</span>
</pre></div>
</div>
<p>We will use scikit-learn to construct a linear model, so we import the
necessary modules. In addition, we need to compute distance matrices when
normalizing our input features, so we import <cite>pdist</cite> from <cite>scipy.spatial</cite>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="p">(</span><span class="n">linear_model</span><span class="p">,</span> <span class="n">model_selection</span><span class="p">,</span> <span class="n">preprocessing</span><span class="p">,</span>
                     <span class="n">pipeline</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="kn">import</span> <span class="n">pdist</span>
</pre></div>
</div>
<p>We then import the necessary functionality from Kymatio. First, we need the
PyTorch frontend of the 3D solid harmonic cattering transform.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">kymatio.torch</span> <span class="kn">import</span> <span class="n">HarmonicScattering3D</span>
</pre></div>
</div>
<p>The 3D transform doesn’t compute the zeroth-order coefficients, so we need
to import <cite>compute_integrals</cite> to do this manually.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">kymatio.scattering3d.backend.torch_backend</span> \
    <span class="kn">import</span> <span class="nn">TorchBackend3D</span>
</pre></div>
</div>
<p>To generate the input 3D maps, we need to calculate sums of Gaussians, so we
import the function <cite>generate_weighted_sum_of_gaussians</cite>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">kymatio.scattering3d.utils</span> \
    <span class="kn">import</span> <span class="nn">generate_weighted_sum_of_gaussians</span>
</pre></div>
</div>
<p>Finally, we import the utility functions that let us access the QM7 dataset
and the cache directories to store our results.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">kymatio.datasets</span> <span class="kn">import</span> <span class="n">fetch_qm7</span>
<span class="kn">from</span> <span class="nn">kymatio.caching</span> <span class="kn">import</span> <span class="n">get_cache_dir</span>
</pre></div>
</div>
</section>
<section id="data-preparation">
<h2>Data preparation<a class="headerlink" href="#data-preparation" title="Permalink to this heading">¶</a></h2>
<p>Fetch the QM7 database and extract the atomic positions and nuclear charges
of each molecule. This dataset contains 7165 organic molecules with up to
seven non-hydrogen atoms, whose energies were computed using density
functional theory.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">qm7</span> <span class="o">=</span> <span class="n">fetch_qm7</span><span class="p">(</span><span class="n">align</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">pos</span> <span class="o">=</span> <span class="n">qm7</span><span class="p">[</span><span class="s1">&#39;positions&#39;</span><span class="p">]</span>
<span class="n">full_charges</span> <span class="o">=</span> <span class="n">qm7</span><span class="p">[</span><span class="s1">&#39;charges&#39;</span><span class="p">]</span>

<span class="n">n_molecules</span> <span class="o">=</span> <span class="n">pos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>From the nuclear charges, we compute the number of valence electrons, which
we store as the valence charge of that atom.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mask</span> <span class="o">=</span> <span class="n">full_charges</span> <span class="o">&lt;=</span> <span class="mi">2</span>
<span class="n">valence_charges</span> <span class="o">=</span> <span class="n">full_charges</span> <span class="o">*</span> <span class="n">mask</span>

<span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">full_charges</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="n">full_charges</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">valence_charges</span> <span class="o">+=</span> <span class="p">(</span><span class="n">full_charges</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">mask</span>

<span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">full_charges</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">,</span> <span class="n">full_charges</span> <span class="o">&lt;=</span> <span class="mi">18</span><span class="p">)</span>
<span class="n">valence_charges</span> <span class="o">+=</span> <span class="p">(</span><span class="n">full_charges</span> <span class="o">-</span> <span class="mi">10</span><span class="p">)</span> <span class="o">*</span> <span class="n">mask</span>
</pre></div>
</div>
<p>We then normalize the positions of the atoms. Specifically, the positions
are rescaled such that two Gaussians of width <cite>sigma</cite> placed at those
positions overlap with amplitude less than <cite>overlapping_precision</cite>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">overlapping_precision</span> <span class="o">=</span> <span class="mf">1e-1</span>
<span class="n">sigma</span> <span class="o">=</span> <span class="mf">2.0</span>
<span class="n">min_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_molecules</span><span class="p">):</span>
    <span class="n">n_atoms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">full_charges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">pos_i</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:</span><span class="n">n_atoms</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">min_dist</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">min_dist</span><span class="p">,</span> <span class="n">pdist</span><span class="p">(</span><span class="n">pos_i</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>

<span class="n">delta</span> <span class="o">=</span> <span class="n">sigma</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="mi">8</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">overlapping_precision</span><span class="p">))</span>
<span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">*</span> <span class="n">delta</span> <span class="o">/</span> <span class="n">min_dist</span>
</pre></div>
</div>
</section>
<section id="scattering-transform">
<h2>Scattering Transform<a class="headerlink" href="#scattering-transform" title="Permalink to this heading">¶</a></h2>
<p>Given the rescaled positions and charges, we are now ready to compute the
density maps by placing Gaussians at the different positions weighted by the
appropriate charge. These are fed into the 3D solid harmonic scattering
transform to obtain features that are used to regress the energies. In
order to do this, we must first define a grid.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">O</span> <span class="o">=</span> <span class="mi">192</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">96</span>

<span class="n">grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="o">-</span><span class="n">M</span><span class="o">//</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="n">M</span><span class="o">//</span><span class="mi">2</span><span class="o">+</span><span class="n">M</span><span class="p">,</span> <span class="o">-</span><span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="o">+</span><span class="n">N</span><span class="p">,</span> <span class="o">-</span><span class="n">O</span><span class="o">//</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="n">O</span><span class="o">//</span><span class="mi">2</span><span class="o">+</span><span class="n">O</span><span class="p">]</span>
<span class="n">grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftshift</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
</pre></div>
</div>
<p>We then define the scattering transform using the <cite>HarmonicScattering3D</cite>
class.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">J</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">L</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">integral_powers</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">]</span>

<span class="n">scattering</span> <span class="o">=</span> <span class="n">HarmonicScattering3D</span><span class="p">(</span><span class="n">J</span><span class="o">=</span><span class="n">J</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">O</span><span class="p">),</span>
                                  <span class="n">L</span><span class="o">=</span><span class="n">L</span><span class="p">,</span> <span class="n">sigma_0</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span>
                                  <span class="n">integral_powers</span><span class="o">=</span><span class="n">integral_powers</span><span class="p">)</span>
</pre></div>
</div>
<p>We then check whether a GPU is available, in which case we transfer our
scattering object there.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">use_cuda</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">()</span>
<span class="n">device</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">&quot;cuda&quot;</span> <span class="k">if</span> <span class="n">use_cuda</span> <span class="k">else</span> <span class="s2">&quot;cpu&quot;</span><span class="p">)</span>
<span class="n">scattering</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
</pre></div>
</div>
<p>The maps computed for each molecule are quite large, so the computation has
to be done by batches. Here we select a small batch size to ensure that we
have enough memory when running on the GPU. Dividing the number of molecules
by the batch size then gives us the number of batches.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">batch_size</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">n_batches</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">n_molecules</span> <span class="o">/</span> <span class="n">batch_size</span><span class="p">))</span>
</pre></div>
</div>
<p>We are now ready to compute the scattering transforms. In the following
loop, each batch of molecules is transformed into three maps using Gaussians
centered at the atomic positions, one for the nuclear charges, one for the
valence charges, and one with their difference (called the “core” charges).
For each map, we compute its scattering transform up to order two and store
the results.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">order_0</span><span class="p">,</span> <span class="n">orders_1_and_2</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Computing solid harmonic scattering coefficients of &#39;</span>
      <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> molecules from the QM7 database on </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">n_molecules</span><span class="p">,</span>   <span class="s2">&quot;GPU&quot;</span> <span class="k">if</span> <span class="n">use_cuda</span> <span class="k">else</span> <span class="s2">&quot;CPU&quot;</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;sigma: </span><span class="si">{}</span><span class="s1">, L: </span><span class="si">{}</span><span class="s1">, J: </span><span class="si">{}</span><span class="s1">, integral powers: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">sigma</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">integral_powers</span><span class="p">))</span>

<span class="n">this_time</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">last_time</span> <span class="o">=</span> <span class="kc">None</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_batches</span><span class="p">):</span>
    <span class="n">this_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">last_time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">this_time</span> <span class="o">-</span> <span class="n">last_time</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Iteration </span><span class="si">{}</span><span class="s2"> ETA: [</span><span class="si">{:02}</span><span class="s2">:</span><span class="si">{:02}</span><span class="s2">:</span><span class="si">{:02}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(((</span><span class="n">n_batches</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span><span class="p">)</span> <span class="o">//</span> <span class="mi">3600</span><span class="p">),</span>
                    <span class="nb">int</span><span class="p">((((</span><span class="n">n_batches</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span><span class="p">)</span> <span class="o">//</span> <span class="mi">60</span><span class="p">)</span> <span class="o">%</span> <span class="mi">60</span><span class="p">),</span>
                    <span class="nb">int</span><span class="p">(((</span><span class="n">n_batches</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span><span class="p">)</span> <span class="o">%</span> <span class="mi">60</span><span class="p">)))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Iteration </span><span class="si">{}</span><span class="s2"> ETA: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">))</span>
    <span class="n">last_time</span> <span class="o">=</span> <span class="n">this_time</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Extract the current batch.</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">batch_size</span>
    <span class="n">end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">n_molecules</span><span class="p">)</span>

    <span class="n">pos_batch</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
    <span class="n">full_batch</span> <span class="o">=</span> <span class="n">full_charges</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
    <span class="n">val_batch</span> <span class="o">=</span> <span class="n">valence_charges</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>

    <span class="c1"># Calculate the density map for the nuclear charges and transfer</span>
    <span class="c1"># to PyTorch.</span>
    <span class="n">full_density_batch</span> <span class="o">=</span> <span class="n">generate_weighted_sum_of_gaussians</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span>
            <span class="n">pos_batch</span><span class="p">,</span> <span class="n">full_batch</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
    <span class="n">full_density_batch</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">full_density_batch</span><span class="p">)</span>
    <span class="n">full_density_batch</span> <span class="o">=</span> <span class="n">full_density_batch</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>

    <span class="c1"># Compute zeroth-order, first-order, and second-order scattering</span>
    <span class="c1"># coefficients of the nuclear charges.</span>
    <span class="n">full_order_0</span> <span class="o">=</span> <span class="n">TorchBackend3D</span><span class="o">.</span><span class="n">compute_integrals</span><span class="p">(</span><span class="n">full_density_batch</span><span class="p">,</span>
                                     <span class="n">integral_powers</span><span class="p">)</span>
    <span class="n">full_scattering</span> <span class="o">=</span> <span class="n">scattering</span><span class="p">(</span><span class="n">full_density_batch</span><span class="p">)</span>

    <span class="c1"># Compute the map for valence charges.</span>
    <span class="n">val_density_batch</span> <span class="o">=</span> <span class="n">generate_weighted_sum_of_gaussians</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span>
            <span class="n">pos_batch</span><span class="p">,</span> <span class="n">val_batch</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
    <span class="n">val_density_batch</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">val_density_batch</span><span class="p">)</span>
    <span class="n">val_density_batch</span> <span class="o">=</span> <span class="n">val_density_batch</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>

    <span class="c1"># Compute scattering coefficients for the valence charges.</span>
    <span class="n">val_order_0</span> <span class="o">=</span> <span class="n">TorchBackend3D</span><span class="o">.</span><span class="n">compute_integrals</span><span class="p">(</span><span class="n">val_density_batch</span><span class="p">,</span>
                                    <span class="n">integral_powers</span><span class="p">)</span>
    <span class="n">val_scattering</span> <span class="o">=</span> <span class="n">scattering</span><span class="p">(</span><span class="n">val_density_batch</span><span class="p">)</span>

    <span class="c1"># Take the difference between nuclear and valence charges, then</span>
    <span class="c1"># compute the corresponding scattering coefficients.</span>
    <span class="n">core_density_batch</span> <span class="o">=</span> <span class="n">full_density_batch</span> <span class="o">-</span> <span class="n">val_density_batch</span>

    <span class="n">core_order_0</span> <span class="o">=</span> <span class="n">TorchBackend3D</span><span class="o">.</span><span class="n">compute_integrals</span><span class="p">(</span><span class="n">core_density_batch</span><span class="p">,</span>
                                     <span class="n">integral_powers</span><span class="p">)</span>
    <span class="n">core_scattering</span> <span class="o">=</span> <span class="n">scattering</span><span class="p">(</span><span class="n">core_density_batch</span><span class="p">)</span>

    <span class="c1"># Stack the nuclear, valence, and core coefficients into arrays</span>
    <span class="c1"># and append them to the output.</span>
    <span class="n">batch_order_0</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
        <span class="p">(</span><span class="n">full_order_0</span><span class="p">,</span> <span class="n">val_order_0</span><span class="p">,</span> <span class="n">core_order_0</span><span class="p">),</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">batch_orders_1_and_2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
        <span class="p">(</span><span class="n">full_scattering</span><span class="p">,</span> <span class="n">val_scattering</span><span class="p">,</span> <span class="n">core_scattering</span><span class="p">),</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">order_0</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">batch_order_0</span><span class="p">)</span>
    <span class="n">orders_1_and_2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">batch_orders_1_and_2</span><span class="p">)</span>
</pre></div>
</div>
<p>Concatenate the batch outputs and transfer to NumPy.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">order_0</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">order_0</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">orders_1_and_2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">orders_1_and_2</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="n">order_0</span> <span class="o">=</span> <span class="n">order_0</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
<span class="n">orders_1_and_2</span> <span class="o">=</span> <span class="n">orders_1_and_2</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="regression">
<h2>Regression<a class="headerlink" href="#regression" title="Permalink to this heading">¶</a></h2>
<p>To use the scattering coefficients as features in a scikit-learn pipeline,
these must be of shape <cite>(n_samples, n_features)</cite>, so we reshape our arrays
accordingly.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">order_0</span> <span class="o">=</span> <span class="n">order_0</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">n_molecules</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="n">orders_1_and_2</span> <span class="o">=</span> <span class="n">orders_1_and_2</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">n_molecules</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>Since the above calculation is quite lengthy, we save the results to a cache
for future use.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">basename</span> <span class="o">=</span> <span class="s1">&#39;qm7_L_</span><span class="si">{}</span><span class="s1">_J_</span><span class="si">{}</span><span class="s1">_sigma_</span><span class="si">{}</span><span class="s1">_MNO_</span><span class="si">{}</span><span class="s1">_powers_</span><span class="si">{}</span><span class="s1">.npy&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">L</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">O</span><span class="p">),</span> <span class="n">integral_powers</span><span class="p">)</span>

<span class="n">cache_dir</span> <span class="o">=</span> <span class="n">get_cache_dir</span><span class="p">(</span><span class="s2">&quot;qm7/experiments&quot;</span><span class="p">)</span>

<span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cache_dir</span><span class="p">,</span> <span class="s1">&#39;order_0_&#39;</span> <span class="o">+</span> <span class="n">basename</span><span class="p">)</span>
<span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">order_0</span><span class="p">)</span>

<span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cache_dir</span><span class="p">,</span> <span class="s1">&#39;orders_1_and_2&#39;</span> <span class="o">+</span> <span class="n">basename</span><span class="p">)</span>
<span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">orders_1_and_2</span><span class="p">)</span>
</pre></div>
</div>
<p>We now concatenate the zeroth-order coefficients with the rest since we want
to use all of them as features.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">scattering_coef</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">order_0</span><span class="p">,</span> <span class="n">orders_1_and_2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Fetch the target energies from the QM7 dataset.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">qm7</span> <span class="o">=</span> <span class="n">fetch_qm7</span><span class="p">()</span>
<span class="n">target</span> <span class="o">=</span> <span class="n">qm7</span><span class="p">[</span><span class="s1">&#39;energies&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>We evaluate the performance of the regression using five-fold
cross-validation. To do so, we first shuffle the molecules, then we store
the resulting indices in <cite>cross_val_folds</cite>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">n_folds</span> <span class="o">=</span> <span class="mi">5</span>

<span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">n_molecules</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">n_folds</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>

<span class="n">cross_val_folds</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">i_fold</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_folds</span><span class="p">):</span>
    <span class="n">fold</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_folds</span><span class="p">)</span> <span class="o">!=</span> <span class="n">i_fold</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
            <span class="n">P</span><span class="p">[</span><span class="n">i_fold</span><span class="p">])</span>
    <span class="n">cross_val_folds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fold</span><span class="p">)</span>
</pre></div>
</div>
<p>Given these folds, we compute the regression error for various settings of
the <cite>alpha</cite> parameter, which controls the amount of regularization applied
to the regression problem (here in the form of a simple ridge regression, or
Tikhonov, regularization). The mean absolute error (MAE) and root mean
square error (RMSE) is output for each value of <cite>alpha</cite>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">alphas</span> <span class="o">=</span> <span class="mf">10.0</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">alpha</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">alphas</span><span class="p">):</span>
    <span class="n">scaler</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">StandardScaler</span><span class="p">()</span>
    <span class="n">ridge</span> <span class="o">=</span> <span class="n">linear_model</span><span class="o">.</span><span class="n">Ridge</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">)</span>

    <span class="n">regressor</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">make_pipeline</span><span class="p">(</span><span class="n">scaler</span><span class="p">,</span> <span class="n">ridge</span><span class="p">)</span>

    <span class="n">target_prediction</span> <span class="o">=</span> <span class="n">model_selection</span><span class="o">.</span><span class="n">cross_val_predict</span><span class="p">(</span><span class="n">regressor</span><span class="p">,</span>
            <span class="n">X</span><span class="o">=</span><span class="n">scattering_coef</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">target</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="n">cross_val_folds</span><span class="p">)</span>

    <span class="n">MAE</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">target_prediction</span> <span class="o">-</span> <span class="n">target</span><span class="p">))</span>
    <span class="n">RMSE</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">target_prediction</span> <span class="o">-</span> <span class="n">target</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Ridge regression, alpha: </span><span class="si">{}</span><span class="s1">, MAE: </span><span class="si">{}</span><span class="s1">, RMSE: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">alpha</span><span class="p">,</span> <span class="n">MAE</span><span class="p">,</span> <span class="n">RMSE</span><span class="p">))</span>
</pre></div>
</div>
<p class="sphx-glr-timing"><strong>Total running time of the script:</strong> ( 0 minutes  0.000 seconds)</p>
<div class="sphx-glr-footer sphx-glr-footer-example docutils container" id="sphx-glr-download-gallery-3d-scattering3d-qm7-torch-py">
<div class="sphx-glr-download sphx-glr-download-python docutils container">
<p><a class="reference download internal" download="" href="../_downloads/7cf359859526cbf0f4d5f1c235300f35/scattering3d_qm7_torch.py"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Python</span> <span class="pre">source</span> <span class="pre">code:</span> <span class="pre">scattering3d_qm7_torch.py</span></code></a></p>
</div>
<div class="sphx-glr-download sphx-glr-download-jupyter docutils container">
<p><a class="reference download internal" download="" href="../_downloads/a0806511345faecfa6a0029911569329/scattering3d_qm7_torch.ipynb"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Jupyter</span> <span class="pre">notebook:</span> <span class="pre">scattering3d_qm7_torch.ipynb</span></code></a></p>
</div>
</div>
<p class="sphx-glr-signature"><a class="reference external" href="https://sphinx-gallery.github.io">Gallery generated by Sphinx-Gallery</a></p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../index.html">
    <img class="logo" src="../_static/kymatio.jpg" alt="Logo"/>
    
  </a>
</p>



<p class="blurb">Wavelet Scattering in Python<br>&nbsp;&nbsp;&nbsp;<a href="https://twitter.com/KymatioWavelets"><img width="40px" src="https://avatars3.githubusercontent.com/u/50278?s=200&v=4"></a></p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=kymatio&repo=kymatio&type=star&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../userguide.html">User guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../developerguide.html">Information for developers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../codereference.html">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gallery_1d/index.html">1D examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gallery_2d/index.html">2D examples</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">3D examples</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">3D scattering quantum chemistry regression</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#preliminaries">Preliminaries</a></li>
<li class="toctree-l3"><a class="reference internal" href="#data-preparation">Data preparation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#scattering-transform">Scattering Transform</a></li>
<li class="toctree-l3"><a class="reference internal" href="#regression">Regression</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../whats_new.html">What’s New</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">3D examples</a><ul>
      <li>Previous: <a href="index.html" title="previous chapter">3D examples</a></li>
      <li>Next: <a href="../whats_new.html" title="next chapter">What’s New</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018–2021, The Kymatio Developers.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.1.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/gallery_3d/scattering3d_qm7_torch.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    
    <a href="https://github.com/kymatio/kymatio" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    
    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-130785726-1']);
      _gaq.push(['_setDomainName', 'none']);
      _gaq.push(['_setAllowLinker', true]);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>
    
  </body>
</html>