
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Documentation &#8212; kymatio 0.3.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="_static/sg_gallery-rendered-html.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="shortcut icon" href="_static/kymatio.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="1D examples" href="gallery_1d/index.html" />
    <link rel="prev" title="Information for developers" href="developerguide.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
    <link rel="apple-touch-icon" href="_static/kymatio.jpg" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="documentation">
<h1>Documentation<a class="headerlink" href="#documentation" title="Permalink to this heading">¶</a></h1>
<section id="module-kymatio.numpy">
<span id="numpy"></span><h2>NumPy<a class="headerlink" href="#module-kymatio.numpy" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="kymatio.numpy.HarmonicScattering3D">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">kymatio.numpy.</span></span><span class="sig-name descname"><span class="pre">HarmonicScattering3D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">J</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">L</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation_covariant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'integral'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">points</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integral_powers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0.5,</span> <span class="pre">1.0,</span> <span class="pre">2.0)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'numpy'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kymatio.numpy.HarmonicScattering3D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">ScatteringNumPy</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ScatteringBase3D</span></code></p>
<p>The 3D solid harmonic scattering transform</p>
<p>This class implements solid harmonic scattering on a 3D input image.
For details see <a class="reference external" href="https://arxiv.org/abs/1805.00571">https://arxiv.org/abs/1805.00571</a>.</p>
<p class="rubric">Example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set the parameters of the scattering transform.</span>
<span class="n">J</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">O</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span>

<span class="c1"># Generate a sample signal.</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">O</span><span class="p">)</span>

<span class="c1"># Define a HarmonicScattering3D object.</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">HarmonicScattering3D</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">O</span><span class="p">))</span>

<span class="c1"># Calculate the scattering transform.</span>
<span class="n">Sx</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">scattering</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># Equivalently, use the alias.</span>
<span class="n">Sx</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>J</strong> (<em>int</em>) – Number of scales.</p></li>
<li><p><strong>shape</strong> (<em>tuple of ints</em>) – Shape <cite>(M, N, O)</cite> of the input signal</p></li>
<li><p><strong>L</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of <cite>l</cite> values. Defaults to <cite>3</cite>.</p></li>
<li><p><strong>sigma_0</strong> (<em>float</em><em>, </em><em>optional</em>) – Bandwidth of mother wavelet. Defaults to <cite>1</cite>.</p></li>
<li><p><strong>max_order</strong> (<em>int</em><em>, </em><em>optional</em>) – The maximum order of scattering coefficients to compute. Must be
either <cite>1</cite> or <cite>2</cite>. Defaults to <cite>2</cite>.</p></li>
<li><p><strong>rotation_covariant</strong> (<em>bool</em><em>, </em><em>optional</em>) – <p>If set to <cite>True</cite> the first-order moduli take the form:</p>
<p><span class="math notranslate nohighlight">\(\sqrt{\sum_m (x \star \psi_{j,l,m})^2)}\)</span></p>
<p>if set to <cite>False</cite> the first-order moduli take the form:</p>
<p><span class="math notranslate nohighlight">\(x \star \psi_{j,l,m}\)</span></p>
<p>The second order moduli change analogously. Defaults to <cite>True</cite>.</p>
</p></li>
<li><p><strong>method</strong> (<em>string</em><em>, </em><em>optional</em>) – Specifies the method for obtaining scattering coefficients.
Currently, only <cite>‘integral’</cite> is available. Defaults to <cite>‘integral’</cite>.</p></li>
<li><p><strong>integral_powers</strong> (<em>array-like</em>) – List of exponents to the power of which moduli are raised before
integration.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="kymatio.numpy.HarmonicScattering3D.build">
<span class="sig-name descname"><span class="pre">build</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#kymatio.numpy.HarmonicScattering3D.build" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines elementary routines.</p>
<p>This function should always call and create the filters via
self.create_filters() defined below. For instance, via:
self.filters = self.create_filters()</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="kymatio.numpy.HarmonicScattering3D.scattering">
<span class="sig-name descname"><span class="pre">scattering</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kymatio.numpy.HarmonicScattering3D.scattering" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the scattering transform</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>input_array</strong> (<em>np.ndarray</em>) – Input of size <cite>(batch_size, M, N, O)</cite>.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>output</strong> – If max_order is <cite>1</cite> it returns an <cite>np.ndarray</cite> with the first-order
scattering coefficients. If max_order is <cite>2</cite> it returns an
<cite>np.ndarray</cite> with the first- and second- order scattering
coefficients, concatenated along the feature axis.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="kymatio.numpy.Scattering1D">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">kymatio.numpy.</span></span><span class="sig-name descname"><span class="pre">Scattering1D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">J</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">average</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">oversampling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'array'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'numpy'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kymatio.numpy.Scattering1D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">ScatteringNumPy</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ScatteringBase1D</span></code></p>
<p>The 1D scattering transform</p>
<blockquote>
<div><p>The scattering transform computes a cascade of wavelet transforms
alternated with a complex modulus non-linearity. The scattering
transform of a 1D signal <span class="math notranslate nohighlight">\(x(t)\)</span> may be written as</p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\(S_J x = [S_J^{(0)} x, S_J^{(1)} x, S_J^{(2)} x]\)</span></p>
</div></blockquote>
<p>where</p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\(S_J^{(0)} x(t) = x \star \phi_J(t)\)</span>,</p>
<p><span class="math notranslate nohighlight">\(S_J^{(1)} x(t, \lambda) = |x \star \psi_\lambda^{(1)}| \star \phi_J\)</span>, and</p>
<p><span class="math notranslate nohighlight">\(S_J^{(2)} x(t, \lambda, \mu) = |\,| x \star \psi_\lambda^{(1)}| \star \psi_\mu^{(2)} | \star \phi_J\)</span>.</p>
</div></blockquote>
<p>In the above formulas, <span class="math notranslate nohighlight">\(\star\)</span> denotes convolution in time. The
filters <span class="math notranslate nohighlight">\(\psi_\lambda^{(1)}(t)\)</span> and <span class="math notranslate nohighlight">\(\psi_\mu^{(2)}(t)\)</span> are analytic
wavelets with center frequencies <span class="math notranslate nohighlight">\(\lambda\)</span> and <span class="math notranslate nohighlight">\(\mu\)</span>, while
<span class="math notranslate nohighlight">\(\phi_J(t)\)</span> is a real lowpass filter centered at the zero frequency.</p>
<p>The <cite>Scattering1D</cite> class implements the 1D scattering transform for a
given set of filters whose parameters are specified at initialization.
While the wavelets are fixed, other parameters may be changed after
the object is created, such as whether to compute all of
<span class="math notranslate nohighlight">\(S_J^{(0)} x\)</span>, <span class="math notranslate nohighlight">\(S_J^{(1)} x\)</span>, and <span class="math notranslate nohighlight">\(S_J^{(2)} x\)</span> or just
<span class="math notranslate nohighlight">\(S_J^{(0)} x\)</span> and <span class="math notranslate nohighlight">\(S_J^{(1)} x\)</span>.</p>
<p>Given an input <cite>np.ndarray</cite> <cite>x</cite> of shape <cite>(B, N)</cite>, where <cite>B</cite> is the
number of signals to transform (the batch size) and <cite>N</cite> is the length
of the signal, we compute its scattering transform by passing it to
the <cite>scattering</cite> method (or calling the alias <cite>__call__</cite>). Note
that <cite>B</cite> can be one, in which case it may be omitted, giving an input
of shape <cite>(N,)</cite>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set the parameters of the scattering transform.</span>
<span class="n">J</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">13</span>
<span class="n">Q</span> <span class="o">=</span> <span class="mi">8</span>

<span class="c1"># Generate a sample signal.</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

<span class="c1"># Define a Scattering1D object.</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">Scattering1D</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>

<span class="c1"># Calculate the scattering transform.</span>
<span class="n">Sx</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">scattering</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># Equivalently, use the alias.</span>
<span class="n">Sx</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>Above, the length of the signal is <span class="math notranslate nohighlight">\(N = 2^{13} = 8192\)</span>, while the
maximum scale of the scattering transform is set to <span class="math notranslate nohighlight">\(2^J = 2^6 =
64\)</span>. The time-frequency resolution of the first-order wavelets
<span class="math notranslate nohighlight">\(\psi_\lambda^{(1)}(t)\)</span> is set to <cite>Q = 8</cite> wavelets per octave.
The second-order wavelets <span class="math notranslate nohighlight">\(\psi_\mu^{(2)}(t)\)</span> always have one
wavelet per octave.</p>
<dl class="simple">
<dt>J<span class="classifier">int</span></dt><dd><p>The maximum log-scale of the scattering transform. In other words,
the maximum scale is given by <span class="math notranslate nohighlight">\(2^J\)</span>.</p>
</dd>
<dt>shape<span class="classifier">int</span></dt><dd><p>The length of the input signals.</p>
</dd>
<dt>Q<span class="classifier">int or tuple</span></dt><dd><p>By default, Q (int) is the number of wavelets per octave for the first
order and that for the second order has one wavelet per octave. This
default value can be modified by passing Q as a tuple with two values,
i.e. Q = (Q1, Q2), where Q1 and Q2 are the number of wavelets per
octave for the first and second order, respectively.</p>
</dd>
<dt>T<span class="classifier">int</span></dt><dd><p>temporal support of low-pass filter, controlling amount of imposed
time-shift invariance and maximum subsampling</p>
</dd>
<dt>max_order<span class="classifier">int, optional</span></dt><dd><p>The maximum order of scattering coefficients to compute. Must be
either <cite>1</cite> or <cite>2</cite>. Defaults to <cite>2</cite>.</p>
</dd>
<dt>average<span class="classifier">boolean, optional</span></dt><dd><p>Determines whether the output is averaged in time or not. The
averaged output corresponds to the standard scattering transform,
while the un-averaged output skips the last convolution by
<span class="math notranslate nohighlight">\(\phi_J(t)\)</span>.  This parameter may be modified after object
creation. Defaults to <cite>True</cite>. Deprecated in v0.3 in favour of <cite>T</cite>
and will  be removed in v0.4. Replace <cite>average=False</cite> by <cite>T=0</cite> and
set <cite>T&gt;1</cite> or leave <cite>T=None</cite> for <cite>average=True</cite> (default).</p>
</dd>
<dt>oversampling<span class="classifier">integer &gt;= 0, optional</span></dt><dd><p>Controls the oversampling factor relative to the default as a
power of two. Since the convolving by wavelets (or lowpass
filters) and taking the modulus reduces the high-frequency content
of the signal, we can subsample to save space and improve
performance. However, this may reduce precision in the
calculation. If this is not desirable, <cite>oversampling</cite> can be set
to a large value to prevent too much subsampling. This parameter
may be modified after object creation. Defaults to <cite>0</cite>.</p>
</dd>
<dt>vectorize<span class="classifier">boolean, optional</span></dt><dd><p>Determines wheter to return a vectorized scattering transform
(that is, a large array containing the output) or a dictionary
(where each entry corresponds to a separate scattering
coefficient). This parameter may be modified after object
creation. Deprecated in favor of <cite>out_type</cite> (see below). Defaults
to True.</p>
</dd>
<dt>out_type<span class="classifier">str, optional</span></dt><dd><p>The format of the output of a scattering transform. If set to
<cite>‘list’</cite>, then the output is a list containing each individual
scattering coefficient with meta information. Otherwise, if set to
<cite>‘array’</cite>, the output is a large array containing the
concatenation of all scattering coefficients. Defaults to
<cite>‘array’</cite>.</p>
</dd>
</dl>
<dl class="simple">
<dt>J<span class="classifier">int</span></dt><dd><p>The maximum log-scale of the scattering transform. In other words,
the maximum scale is given by <cite>2 ** J</cite>.</p>
</dd>
<dt>shape<span class="classifier">int</span></dt><dd><p>The length of the input signals.</p>
</dd>
<dt>Q<span class="classifier">int</span></dt><dd><p>The number of first-order wavelets per octave (second-order
wavelets are fixed to one wavelet per octave).</p>
</dd>
<dt>T<span class="classifier">int</span></dt><dd><p>temporal support of low-pass filter, controlling amount of imposed
time-shift invariance and maximum subsampling</p>
</dd>
<dt>pad_left<span class="classifier">int</span></dt><dd><p>The amount of padding to the left of the signal.</p>
</dd>
<dt>pad_right<span class="classifier">int</span></dt><dd><p>The amount of padding to the right of the signal.</p>
</dd>
<dt>phi_f<span class="classifier">dictionary</span></dt><dd><p>A dictionary containing the lowpass filter at all resolutions. See
<cite>filter_bank.scattering_filter_factory</cite> for an exact description.</p>
</dd>
<dt>psi1_f<span class="classifier">dictionary</span></dt><dd><p>A dictionary containing all the first-order wavelet filters, each
represented as a dictionary containing that filter at all
resolutions. See <cite>filter_bank.scattering_filter_factory</cite> for an
exact description.</p>
</dd>
<dt>psi2_f<span class="classifier">dictionary</span></dt><dd><p>A dictionary containing all the second-order wavelet filters, each
represented as a dictionary containing that filter at all
resolutions. See <cite>filter_bank.scattering_filter_factory</cite> for an
exact description.</p>
</dd>
<dt>max_order<span class="classifier">int</span></dt><dd><p>The maximum scattering order of the transform.</p>
</dd>
<dt>average<span class="classifier">boolean</span></dt><dd><p>Controls whether the output should be averaged (the standard
scattering transform) or not (resulting in wavelet modulus
coefficients). Note that to obtain unaveraged output, the
<cite>vectorize</cite> flag must be set to <cite>False</cite> or <cite>out_type</cite> must be set
to <cite>‘list’</cite>. Deprecated in favor of <cite>T</cite>. For more details,
see the documentation for <cite>scattering</cite>.</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>oversampling<span class="classifier">int</span></dt><dd><blockquote>
<div><p>The number of powers of two to oversample the output compared to
the default subsampling rate determined from the filters.</p>
</div></blockquote>
<dl class="simple">
<dt>vectorize<span class="classifier">boolean</span></dt><dd><p>Controls whether the output should be vectorized into a single
Tensor or collected into a dictionary. Deprecated in favor of
<cite>out_type</cite>. For more details, see the documentation for
<cite>scattering</cite>.</p>
</dd>
<dt>out_type<span class="classifier">str</span></dt><dd><p>Specifices the output format of the transform, which is currently
one of <cite>‘array’</cite> or <cite>‘list</cite>’. If <cite>‘array’</cite>, the output is a large
array containing the scattering coefficients. If <cite>‘list</cite>’, the
output is a list of dictionaries, each containing a scattering
coefficient along with meta information. For more information, see
the documentation for <cite>scattering</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="kymatio.numpy.Scattering1D.scattering">
<span class="sig-name descname"><span class="pre">scattering</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kymatio.numpy.Scattering1D.scattering" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the scattering transform</p>
<p>Given an input <cite>np.ndarray</cite> of size <cite>(B, N)</cite>, where <cite>B</cite> is the batch
size (it can be potentially an integer or a shape) and <cite>N</cite> is the length
of the individual signals, this function computes its scattering
transform. If the <cite>vectorize</cite> flag is set to <cite>True</cite> (or if it is not
available in this frontend), the output is in the form of a <cite>np.ndarray</cite>
or size <cite>(B, C, N1)</cite>, where <cite>N1</cite> is the signal length after subsampling
to the scale <span class="math notranslate nohighlight">\(2^J\)</span> (with the appropriate oversampling factor to
reduce aliasing), and <cite>C</cite> is the number of scattering coefficients. If
<cite>vectorize</cite> is set <cite>False</cite>, however, the output is a dictionary
containing <cite>C</cite> keys, each a tuple whose length corresponds to the
scattering order and whose elements are the sequence of filter indices
used.</p>
<p>Note that the <cite>vectorize</cite> flag has been deprecated in favor of the
<cite>out_type</cite> parameter. If this is set to <cite>‘array’</cite> (the default), the
<cite>vectorize</cite> flag is still respected, but if not, <cite>out_type</cite> takes
precedence. The two current output types are <cite>‘array’</cite> and <cite>‘list’</cite>.
The former gives the type of output described above. If set to
<cite>‘list’</cite>, however, the output is a list of dictionaries, each
dictionary corresponding to a scattering coefficient and its associated
meta information. The coefficient is stored under the <cite>‘coef’</cite> key,
while other keys contain additional information, such as <cite>‘j’</cite> (the
scale of the filter used) and <cite>‘n</cite>’ (the filter index).</p>
<p>Furthermore, if the <cite>average</cite> flag is set to <cite>False</cite>, these outputs
are not averaged, but are simply the wavelet modulus coefficients of
the filters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<em>np.ndarray</em>) – An input <cite>np.ndarray</cite> of size <cite>(B, N)</cite>.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>S</strong> – If <cite>out_type</cite> is <cite>‘array’</cite> and the <cite>vectorize</cite> flag is <cite>True</cite>, the
output is an <cite>np.ndarray</cite> containing the scattering coefficients,
while if <cite>vectorize</cite> is <cite>False</cite>, it is a dictionary indexed by
tuples of filter indices. If <cite>out_type</cite> is <cite>‘list’</cite>, the output is
a list of dictionaries as described above.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tensor or dictionary</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="kymatio.numpy.Scattering2D">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">kymatio.numpy.</span></span><span class="sig-name descname"><span class="pre">Scattering2D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">J</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">L</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_pad</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'numpy'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'array'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kymatio.numpy.Scattering2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">ScatteringNumPy</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ScatteringBase2D</span></code></p>
<p>The 2D scattering transform</p>
<p>The scattering transform computes two wavelet transform
followed by modulus non-linearity. It can be summarized as</p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\(S_J x = [S_J^{(0)} x, S_J^{(1)} x, S_J^{(2)} x]\)</span></p>
</div></blockquote>
<p>where</p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\(S_J^{(0)} x = x \star \phi_J\)</span>,</p>
<p><span class="math notranslate nohighlight">\(S_J^{(1)} x = [|x \star \psi^{(1)}_\lambda| \star \phi_J]_\lambda\)</span>, and</p>
<p><span class="math notranslate nohighlight">\(S_J^{(2)} x = [||x \star \psi^{(1)}_\lambda| \star
\psi^{(2)}_\mu| \star \phi_J]_{\lambda, \mu}\)</span>.</p>
</div></blockquote>
<p>where <span class="math notranslate nohighlight">\(\star\)</span> denotes the convolution (in space), <span class="math notranslate nohighlight">\(\phi_J\)</span> is a
lowpass filter, <span class="math notranslate nohighlight">\(\psi^{(1)}_\lambda\)</span> is a family of bandpass filters
and <span class="math notranslate nohighlight">\(\psi^{(2)}_\mu\)</span> is another family of bandpass filters. Only
Morlet filters are used in this implementation. Convolutions are
efficiently performed in the Fourier domain.</p>
<p class="rubric">Example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set the parameters of the scattering transform.</span>
<span class="n">J</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">M</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span>

<span class="c1"># Generate a sample signal.</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>

<span class="c1"># Define a Scattering2D object.</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">Scattering2D</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>

<span class="c1"># Calculate the scattering transform.</span>
<span class="n">Sx</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">scattering</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># Equivalently, use the alias.</span>
<span class="n">Sx</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>J</strong> (<em>int</em>) – Log-2 of the scattering scale.</p></li>
<li><p><strong>shape</strong> (<em>tuple of ints</em>) – Spatial support (M, N) of the input</p></li>
<li><p><strong>L</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of angles used for the wavelet transform. Defaults to <cite>8</cite>.</p></li>
<li><p><strong>max_order</strong> (<em>int</em><em>, </em><em>optional</em>) – The maximum order of scattering coefficients to compute. Must be
either <cite>1</cite> or <cite>2</cite>. Defaults to <cite>2</cite>.</p></li>
<li><p><strong>pre_pad</strong> (<em>boolean</em><em>, </em><em>optional</em>) – Controls the padding: if set to False, a symmetric padding is
applied on the signal. If set to True, the software will assume
the signal was padded externally. Defaults to <cite>False</cite>.</p></li>
<li><p><strong>backend</strong> (<em>object</em><em>, </em><em>optional</em>) – Controls the backend which is combined with the frontend.</p></li>
<li><p><strong>out_type</strong> (<em>str</em><em>, </em><em>optional</em>) – The format of the output of a scattering transform. If set to
<cite>‘list’</cite>, then the output is a list containing each individual
scattering path with meta information. Otherwise, if set to
<cite>‘array’</cite>, the output is a large array containing the
concatenation of all scattering coefficients. Defaults to
<cite>‘array’</cite>.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.numpy.Scattering2D.J">
<span class="sig-name descname"><span class="pre">J</span></span><a class="headerlink" href="#kymatio.numpy.Scattering2D.J" title="Permalink to this definition">¶</a></dt>
<dd><p>Log-2 of the scattering scale.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.numpy.Scattering2D.shape">
<span class="sig-name descname"><span class="pre">shape</span></span><a class="headerlink" href="#kymatio.numpy.Scattering2D.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Spatial support (M, N) of the input</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple of ints</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.numpy.Scattering2D.L">
<span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#kymatio.numpy.Scattering2D.L" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of angles used for the wavelet transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int, optional</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.numpy.Scattering2D.max_order">
<span class="sig-name descname"><span class="pre">max_order</span></span><a class="headerlink" href="#kymatio.numpy.Scattering2D.max_order" title="Permalink to this definition">¶</a></dt>
<dd><p>The maximum order of scattering coefficients to compute.
Must be either <cite>1</cite> or <cite>2</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int, optional</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.numpy.Scattering2D.pre_pad">
<span class="sig-name descname"><span class="pre">pre_pad</span></span><a class="headerlink" href="#kymatio.numpy.Scattering2D.pre_pad" title="Permalink to this definition">¶</a></dt>
<dd><p>Controls the padding: if set to False, a symmetric padding is
applied on the signal. If set to True, the software will assume
the signal was padded externally.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>boolean</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.numpy.Scattering2D.Psi">
<span class="sig-name descname"><span class="pre">Psi</span></span><a class="headerlink" href="#kymatio.numpy.Scattering2D.Psi" title="Permalink to this definition">¶</a></dt>
<dd><p>Contains the wavelets filters at all resolutions. See
<cite>filter_bank.filter_bank</cite> for an exact description.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.numpy.Scattering2D.Phi">
<span class="sig-name descname"><span class="pre">Phi</span></span><a class="headerlink" href="#kymatio.numpy.Scattering2D.Phi" title="Permalink to this definition">¶</a></dt>
<dd><p>Contains the low-pass filters at all resolutions. See
<cite>filter_bank.filter_bank</cite> for an exact description.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">M_padded,</span> <span class="pre">N_padded</span></span></dt>
<dd><p>Spatial support of the padded input.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.numpy.Scattering2D.out_type">
<span class="sig-name descname"><span class="pre">out_type</span></span><a class="headerlink" href="#kymatio.numpy.Scattering2D.out_type" title="Permalink to this definition">¶</a></dt>
<dd><p>The format of the scattering output. See documentation for
<cite>out_type</cite> parameter above and the documentation for <cite>scattering</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Notes</p>
<p>The design of the filters is optimized for the value <cite>L = 8</cite>.</p>
<p>The <cite>pre_pad</cite> flag is particularly useful when cropping bigger images
because this does not introduce border effects inherent to padding.</p>
<dl class="py method">
<dt class="sig sig-object py" id="kymatio.numpy.Scattering2D.scattering">
<span class="sig-name descname"><span class="pre">scattering</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kymatio.numpy.Scattering2D.scattering" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the scattering transform</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>input</strong> (<em>np.ndarray</em>) – An input <cite>np.ndarray</cite> of size <cite>(B, M, N)</cite>.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError</strong> – In the event that the input does not have at least two dimensions,
or the tensor is not contiguous, or the tensor is not of the
correct spatial size, padded or not.</p></li>
<li><p><strong>TypeError</strong> – In the event that the input is not of type <cite>np.ndarray</cite>.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>S</strong> – Scattering transform of the input. If <cite>out_type</cite> is set to
<cite>‘array’</cite> (or if it is not availabel for this frontend), this is
an <cite>np.ndarray</cite> of shape <cite>(B, C, M1, N1)</cite> where <cite>M1 = M // 2 ** J</cite>
and <cite>N1 = N // 2 ** J</cite>. The <cite>C</cite> is the number of scattering
channels calculated. If <cite>out_type</cite> is <cite>‘list’</cite>, the output is a
list of dictionaries, with each dictionary corresponding to a
scattering coefficient and its meta information. The actual
coefficient is contained in the <cite>‘coef’</cite> key, while other keys hold
additional information, such as <cite>‘j’</cite> (the scale of the filter
used), and <cite>‘theta’</cite> (the angle index of the filter used).</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-kymatio.sklearn">
<span id="scikit-learn"></span><h2>Scikit-learn<a class="headerlink" href="#module-kymatio.sklearn" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="kymatio.sklearn.HarmonicScattering3D">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">kymatio.sklearn.</span></span><span class="sig-name descname"><span class="pre">HarmonicScattering3D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">J</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">L</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation_covariant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'integral'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">points</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integral_powers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0.5,</span> <span class="pre">1.0,</span> <span class="pre">2.0)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'numpy'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kymatio.sklearn.HarmonicScattering3D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">ScatteringTransformerMixin</span></code>, <a class="reference internal" href="#kymatio.numpy.HarmonicScattering3D" title="kymatio.numpy.HarmonicScatteringNumPy3D"><code class="xref py py-class docutils literal notranslate"><span class="pre">HarmonicScatteringNumPy3D</span></code></a></p>
<p>The 3D solid harmonic scattering transform</p>
<p>This class implements solid harmonic scattering on a 3D input image.
For details see <a class="reference external" href="https://arxiv.org/abs/1805.00571">https://arxiv.org/abs/1805.00571</a>.</p>
<p>This class inherits from <cite>BaseEstimator</cite> and <cite>TransformerMixin</cite> in
<cite>sklearn.base</cite>. As a result, it supports calculating the scattering
transform by calling the <cite>predict</cite> and <cite>transform</cite> methods. By
extension, it can be included as part of a scikit-learn <cite>Pipeline</cite>.</p>
<p class="rubric">Example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set the parameters of the scattering transform.</span>
<span class="n">J</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">O</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span>

<span class="c1"># Generate a sample signal.</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">O</span><span class="p">))</span>

<span class="c1"># Define a HarmonicScattering3D object.</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">HarmonicScattering3D</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">O</span><span class="p">))</span>

<span class="c1"># Calculate the scattering transform.</span>
<span class="n">Sx</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">scattering</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># Equivalently, use the alias.</span>
<span class="n">Sx</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>J</strong> (<em>int</em>) – Number of scales.</p></li>
<li><p><strong>shape</strong> (<em>tuple of ints</em>) – Shape <cite>(M, N, O)</cite> of the input signal</p></li>
<li><p><strong>L</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of <cite>l</cite> values. Defaults to <cite>3</cite>.</p></li>
<li><p><strong>sigma_0</strong> (<em>float</em><em>, </em><em>optional</em>) – Bandwidth of mother wavelet. Defaults to <cite>1</cite>.</p></li>
<li><p><strong>max_order</strong> (<em>int</em><em>, </em><em>optional</em>) – The maximum order of scattering coefficients to compute. Must be
either <cite>1</cite> or <cite>2</cite>. Defaults to <cite>2</cite>.</p></li>
<li><p><strong>rotation_covariant</strong> (<em>bool</em><em>, </em><em>optional</em>) – <p>If set to <cite>True</cite> the first-order moduli take the form:</p>
<p><span class="math notranslate nohighlight">\(\sqrt{\sum_m (x \star \psi_{j,l,m})^2)}\)</span></p>
<p>if set to <cite>False</cite> the first-order moduli take the form:</p>
<p><span class="math notranslate nohighlight">\(x \star \psi_{j,l,m}\)</span></p>
<p>The second order moduli change analogously. Defaults to <cite>True</cite>.</p>
</p></li>
<li><p><strong>method</strong> (<em>string</em><em>, </em><em>optional</em>) – Specifies the method for obtaining scattering coefficients.
Currently, only <cite>‘integral’</cite> is available. Defaults to <cite>‘integral’</cite>.</p></li>
<li><p><strong>integral_powers</strong> (<em>array-like</em>) – List of exponents to the power of which moduli are raised before
integration.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="kymatio.sklearn.Scattering1D">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">kymatio.sklearn.</span></span><span class="sig-name descname"><span class="pre">Scattering1D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">J</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">average</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">oversampling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'array'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'numpy'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kymatio.sklearn.Scattering1D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">ScatteringTransformerMixin</span></code>, <a class="reference internal" href="#kymatio.numpy.Scattering1D" title="kymatio.numpy.ScatteringNumPy1D"><code class="xref py py-class docutils literal notranslate"><span class="pre">ScatteringNumPy1D</span></code></a></p>
<p>The 1D scattering transform</p>
<p>The scattering transform computes a cascade of wavelet transforms
alternated with a complex modulus non-linearity. The scattering
transform of a 1D signal <span class="math notranslate nohighlight">\(x(t)\)</span> may be written as</p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\(S_J x = [S_J^{(0)} x, S_J^{(1)} x, S_J^{(2)} x]\)</span></p>
</div></blockquote>
<p>where</p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\(S_J^{(0)} x(t) = x \star \phi_J(t)\)</span>,</p>
<p><span class="math notranslate nohighlight">\(S_J^{(1)} x(t, \lambda) = |x \star \psi_\lambda^{(1)}| \star \phi_J\)</span>, and</p>
<p><span class="math notranslate nohighlight">\(S_J^{(2)} x(t, \lambda, \mu) = |\,| x \star \psi_\lambda^{(1)}| \star \psi_\mu^{(2)} | \star \phi_J\)</span>.</p>
</div></blockquote>
<p>In the above formulas, <span class="math notranslate nohighlight">\(\star\)</span> denotes convolution in time. The
filters <span class="math notranslate nohighlight">\(\psi_\lambda^{(1)}(t)\)</span> and <span class="math notranslate nohighlight">\(\psi_\mu^{(2)}(t)\)</span> are analytic
wavelets with center frequencies <span class="math notranslate nohighlight">\(\lambda\)</span> and <span class="math notranslate nohighlight">\(\mu\)</span>, while
<span class="math notranslate nohighlight">\(\phi_J(t)\)</span> is a real lowpass filter centered at the zero frequency.</p>
<p>The <cite>Scattering1D</cite> class implements the 1D scattering transform for a
given set of filters whose parameters are specified at initialization.
While the wavelets are fixed, other parameters may be changed after
the object is created, such as whether to compute all of
<span class="math notranslate nohighlight">\(S_J^{(0)} x\)</span>, <span class="math notranslate nohighlight">\(S_J^{(1)} x\)</span>, and <span class="math notranslate nohighlight">\(S_J^{(2)} x\)</span> or just
<span class="math notranslate nohighlight">\(S_J^{(0)} x\)</span> and <span class="math notranslate nohighlight">\(S_J^{(1)} x\)</span>.</p>
<p>This class inherits from <cite>BaseEstimator</cite> and <cite>TransformerMixin</cite> in
<cite>sklearn.base</cite>. As a result, it supports calculating the scattering
transform by calling the <cite>predict</cite> and <cite>transform</cite> methods. By
extension, it can be included as part of a scikit-learn <cite>Pipeline</cite>.</p>
<p>Given an input <cite>np.ndarray</cite> <cite>x</cite> of shape <cite>(B, N)</cite>, where <cite>B</cite> is the
number of signals to transform (the batch size) and <cite>N</cite> is the length
of the signal, we compute its scattering transform by passing it to
the <cite>scattering</cite> method (or calling the alias <cite>predict</cite>). Note
that <cite>B</cite> can be one, in which case it may be omitted, giving an input
of shape <cite>(N,)</cite>.</p>
<p class="rubric">Example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set the parameters of the scattering transform.</span>
<span class="n">J</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">13</span>
<span class="n">Q</span> <span class="o">=</span> <span class="mi">8</span>

<span class="c1"># Generate a sample signal.</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>

<span class="c1"># Define a Scattering1D object.</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">Scattering1D</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>

<span class="c1"># Calculate the scattering transform.</span>
<span class="n">Sx</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">scattering</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># Equivalently, use the alias.</span>
<span class="n">Sx</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>Above, the length of the signal is <span class="math notranslate nohighlight">\(N = 2^{13} = 8192\)</span>, while the
maximum scale of the scattering transform is set to <span class="math notranslate nohighlight">\(2^J = 2^6 =
64\)</span>. The time-frequency resolution of the first-order wavelets
<span class="math notranslate nohighlight">\(\psi_\lambda^{(1)}(t)\)</span> is set to <cite>Q = 8</cite> wavelets per octave.
The second-order wavelets <span class="math notranslate nohighlight">\(\psi_\mu^{(2)}(t)\)</span> always have one
wavelet per octave.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>J</strong> (<em>int</em>) – The maximum log-scale of the scattering transform. In other words,
the maximum scale is given by <span class="math notranslate nohighlight">\(2^J\)</span>.</p></li>
<li><p><strong>shape</strong> (<em>int</em>) – The length of the input signals.</p></li>
<li><p><strong>Q</strong> (<em>int</em><em> or </em><em>tuple</em>) – By default, Q (int) is the number of wavelets per octave for the first
order and that for the second order has one wavelet per octave. This
default value can be modified by passing Q as a tuple with two values,
i.e. Q = (Q1, Q2), where Q1 and Q2 are the number of wavelets per
octave for the first and second order, respectively.</p></li>
<li><p><strong>T</strong> (<em>int</em>) – temporal support of low-pass filter, controlling amount of imposed
time-shift invariance and maximum subsampling</p></li>
<li><p><strong>max_order</strong> (<em>int</em><em>, </em><em>optional</em>) – The maximum order of scattering coefficients to compute. Must be
either <cite>1</cite> or <cite>2</cite>. Defaults to <cite>2</cite>.</p></li>
<li><p><strong>oversampling</strong> (<em>integer &gt;= 0</em><em>, </em><em>optional</em>) – Controls the oversampling factor relative to the default as a
power of two. Since the convolving by wavelets (or lowpass
filters) and taking the modulus reduces the high-frequency content
of the signal, we can subsample to save space and improve
performance. However, this may reduce precision in the
calculation. If this is not desirable, <cite>oversampling</cite> can be set
to a large value to prevent too much subsampling. This parameter
may be modified after object creation. Defaults to <cite>0</cite>.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.sklearn.Scattering1D.J">
<span class="sig-name descname"><span class="pre">J</span></span><a class="headerlink" href="#kymatio.sklearn.Scattering1D.J" title="Permalink to this definition">¶</a></dt>
<dd><p>The maximum log-scale of the scattering transform. In other words,
the maximum scale is given by <cite>2 ** J</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.sklearn.Scattering1D.shape">
<span class="sig-name descname"><span class="pre">shape</span></span><a class="headerlink" href="#kymatio.sklearn.Scattering1D.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>The length of the input signals.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.sklearn.Scattering1D.Q">
<span class="sig-name descname"><span class="pre">Q</span></span><a class="headerlink" href="#kymatio.sklearn.Scattering1D.Q" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of first-order wavelets per octave (second-order
wavelets are fixed to one wavelet per octave).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.sklearn.Scattering1D.T">
<span class="sig-name descname"><span class="pre">T</span></span><a class="headerlink" href="#kymatio.sklearn.Scattering1D.T" title="Permalink to this definition">¶</a></dt>
<dd><p>temporal support of low-pass filter, controlling amount of imposed
time-shift invariance and maximum subsampling</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.sklearn.Scattering1D.pad_left">
<span class="sig-name descname"><span class="pre">pad_left</span></span><a class="headerlink" href="#kymatio.sklearn.Scattering1D.pad_left" title="Permalink to this definition">¶</a></dt>
<dd><p>The amount of padding to the left of the signal.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.sklearn.Scattering1D.pad_right">
<span class="sig-name descname"><span class="pre">pad_right</span></span><a class="headerlink" href="#kymatio.sklearn.Scattering1D.pad_right" title="Permalink to this definition">¶</a></dt>
<dd><p>The amount of padding to the right of the signal.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.sklearn.Scattering1D.phi_f">
<span class="sig-name descname"><span class="pre">phi_f</span></span><a class="headerlink" href="#kymatio.sklearn.Scattering1D.phi_f" title="Permalink to this definition">¶</a></dt>
<dd><p>A dictionary containing the lowpass filter at all resolutions. See
<cite>filter_bank.scattering_filter_factory</cite> for an exact description.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.sklearn.Scattering1D.psi1_f">
<span class="sig-name descname"><span class="pre">psi1_f</span></span><a class="headerlink" href="#kymatio.sklearn.Scattering1D.psi1_f" title="Permalink to this definition">¶</a></dt>
<dd><p>A dictionary containing all the first-order wavelet filters, each
represented as a dictionary containing that filter at all
resolutions. See <cite>filter_bank.scattering_filter_factory</cite> for an
exact description.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.sklearn.Scattering1D.psi2_f">
<span class="sig-name descname"><span class="pre">psi2_f</span></span><a class="headerlink" href="#kymatio.sklearn.Scattering1D.psi2_f" title="Permalink to this definition">¶</a></dt>
<dd><p>A dictionary containing all the second-order wavelet filters, each
represented as a dictionary containing that filter at all
resolutions. See <cite>filter_bank.scattering_filter_factory</cite> for an
exact description.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.sklearn.Scattering1D.max_order">
<span class="sig-name descname"><span class="pre">max_order</span></span><a class="headerlink" href="#kymatio.sklearn.Scattering1D.max_order" title="Permalink to this definition">¶</a></dt>
<dd><p>The maximum scattering order of the transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.sklearn.Scattering1D.oversampling">
<span class="sig-name descname"><span class="pre">oversampling</span></span><a class="headerlink" href="#kymatio.sklearn.Scattering1D.oversampling" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of powers of two to oversample the output compared to
the default subsampling rate determined from the filters.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="kymatio.sklearn.Scattering2D">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">kymatio.sklearn.</span></span><span class="sig-name descname"><span class="pre">Scattering2D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">J</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">L</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_pad</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'numpy'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'array'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kymatio.sklearn.Scattering2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">ScatteringTransformerMixin</span></code>, <a class="reference internal" href="#kymatio.numpy.Scattering2D" title="kymatio.numpy.ScatteringNumPy2D"><code class="xref py py-class docutils literal notranslate"><span class="pre">ScatteringNumPy2D</span></code></a></p>
<p>The 2D scattering transform</p>
<p>The scattering transform computes two wavelet transform
followed by modulus non-linearity. It can be summarized as</p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\(S_J x = [S_J^{(0)} x, S_J^{(1)} x, S_J^{(2)} x]\)</span></p>
</div></blockquote>
<p>where</p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\(S_J^{(0)} x = x \star \phi_J\)</span>,</p>
<p><span class="math notranslate nohighlight">\(S_J^{(1)} x = [|x \star \psi^{(1)}_\lambda| \star \phi_J]_\lambda\)</span>, and</p>
<p><span class="math notranslate nohighlight">\(S_J^{(2)} x = [||x \star \psi^{(1)}_\lambda| \star
\psi^{(2)}_\mu| \star \phi_J]_{\lambda, \mu}\)</span>.</p>
</div></blockquote>
<p>where <span class="math notranslate nohighlight">\(\star\)</span> denotes the convolution (in space), <span class="math notranslate nohighlight">\(\phi_J\)</span> is a
lowpass filter, <span class="math notranslate nohighlight">\(\psi^{(1)}_\lambda\)</span> is a family of bandpass filters
and <span class="math notranslate nohighlight">\(\psi^{(2)}_\mu\)</span> is another family of bandpass filters. Only
Morlet filters are used in this implementation. Convolutions are
efficiently performed in the Fourier domain.</p>
<p>This class inherits from <cite>BaseEstimator</cite> and <cite>TransformerMixin</cite> in
<cite>sklearn.base</cite>. As a result, it supports calculating the scattering
transform by calling the <cite>predict</cite> and <cite>transform</cite> methods. By
extension, it can be included as part of a scikit-learn <cite>Pipeline</cite>.</p>
<p class="rubric">Example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set the parameters of the scattering transform.</span>
<span class="n">J</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">M</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span>

<span class="c1"># Generate a sample signal.</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>

<span class="c1"># Define a Scattering2D object.</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">Scattering2D</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>

<span class="c1"># Calculate the scattering transform.</span>
<span class="n">Sx</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">scattering</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># Equivalently, use the alias.</span>
<span class="n">Sx</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>J</strong> (<em>int</em>) – Log-2 of the scattering scale.</p></li>
<li><p><strong>shape</strong> (<em>tuple of ints</em>) – Spatial support (M, N) of the input</p></li>
<li><p><strong>L</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of angles used for the wavelet transform. Defaults to <cite>8</cite>.</p></li>
<li><p><strong>max_order</strong> (<em>int</em><em>, </em><em>optional</em>) – The maximum order of scattering coefficients to compute. Must be
either <cite>1</cite> or <cite>2</cite>. Defaults to <cite>2</cite>.</p></li>
<li><p><strong>pre_pad</strong> (<em>boolean</em><em>, </em><em>optional</em>) – Controls the padding: if set to False, a symmetric padding is
applied on the signal. If set to True, the software will assume
the signal was padded externally. Defaults to <cite>False</cite>.</p></li>
<li><p><strong>backend</strong> (<em>object</em><em>, </em><em>optional</em>) – Controls the backend which is combined with the frontend.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.sklearn.Scattering2D.J">
<span class="sig-name descname"><span class="pre">J</span></span><a class="headerlink" href="#kymatio.sklearn.Scattering2D.J" title="Permalink to this definition">¶</a></dt>
<dd><p>Log-2 of the scattering scale.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.sklearn.Scattering2D.shape">
<span class="sig-name descname"><span class="pre">shape</span></span><a class="headerlink" href="#kymatio.sklearn.Scattering2D.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Spatial support (M, N) of the input</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple of ints</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.sklearn.Scattering2D.L">
<span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#kymatio.sklearn.Scattering2D.L" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of angles used for the wavelet transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int, optional</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.sklearn.Scattering2D.max_order">
<span class="sig-name descname"><span class="pre">max_order</span></span><a class="headerlink" href="#kymatio.sklearn.Scattering2D.max_order" title="Permalink to this definition">¶</a></dt>
<dd><p>The maximum order of scattering coefficients to compute.
Must be either <cite>1</cite> or <cite>2</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int, optional</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.sklearn.Scattering2D.pre_pad">
<span class="sig-name descname"><span class="pre">pre_pad</span></span><a class="headerlink" href="#kymatio.sklearn.Scattering2D.pre_pad" title="Permalink to this definition">¶</a></dt>
<dd><p>Controls the padding: if set to False, a symmetric padding is
applied on the signal. If set to True, the software will assume
the signal was padded externally.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>boolean</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.sklearn.Scattering2D.Psi">
<span class="sig-name descname"><span class="pre">Psi</span></span><a class="headerlink" href="#kymatio.sklearn.Scattering2D.Psi" title="Permalink to this definition">¶</a></dt>
<dd><p>Contains the wavelets filters at all resolutions. See
<cite>filter_bank.filter_bank</cite> for an exact description.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.sklearn.Scattering2D.Phi">
<span class="sig-name descname"><span class="pre">Phi</span></span><a class="headerlink" href="#kymatio.sklearn.Scattering2D.Phi" title="Permalink to this definition">¶</a></dt>
<dd><p>Contains the low-pass filters at all resolutions. See
<cite>filter_bank.filter_bank</cite> for an exact description.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">M_padded,</span> <span class="pre">N_padded</span></span></dt>
<dd><p>Spatial support of the padded input.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Notes</p>
<p>The design of the filters is optimized for the value <cite>L = 8</cite>.</p>
<p>The <cite>pre_pad</cite> flag is particularly useful when cropping bigger images
because this does not introduce border effects inherent to padding.</p>
</dd></dl>

</section>
<section id="module-kymatio.torch">
<span id="pytorch"></span><h2>PyTorch<a class="headerlink" href="#module-kymatio.torch" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="kymatio.torch.HarmonicScattering3D">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">kymatio.torch.</span></span><span class="sig-name descname"><span class="pre">HarmonicScattering3D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">J</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">L</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation_covariant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'integral'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">points</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integral_powers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0.5,</span> <span class="pre">1.0,</span> <span class="pre">2.0)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'torch'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kymatio.torch.HarmonicScattering3D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">ScatteringTorch</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ScatteringBase3D</span></code></p>
<p>The 3D solid harmonic scattering transform</p>
<p>This class implements solid harmonic scattering on a 3D input image.
For details see <a class="reference external" href="https://arxiv.org/abs/1805.00571">https://arxiv.org/abs/1805.00571</a>.</p>
<p>This class inherits from <cite>torch.nn.Module</cite>. As a result, it has all
the same capabilities, including transferring the object to the GPU
using the <cite>cuda</cite> or <cite>to</cite> methods. This object would then take GPU
tensors as input and output the scattering coefficients of those
tensors.</p>
<p class="rubric">Example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set the parameters of the scattering transform.</span>
<span class="n">J</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">O</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span>

<span class="c1"># Generate a sample signal.</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">O</span><span class="p">)</span>

<span class="c1"># Define a HarmonicScattering3D object.</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">HarmonicScattering3D</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">O</span><span class="p">))</span>

<span class="c1"># Calculate the scattering transform.</span>
<span class="n">Sx</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">scattering</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># Equivalently, use the alias.</span>
<span class="n">Sx</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>J</strong> (<em>int</em>) – Number of scales.</p></li>
<li><p><strong>shape</strong> (<em>tuple of ints</em>) – Shape <cite>(M, N, O)</cite> of the input signal</p></li>
<li><p><strong>L</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of <cite>l</cite> values. Defaults to <cite>3</cite>.</p></li>
<li><p><strong>sigma_0</strong> (<em>float</em><em>, </em><em>optional</em>) – Bandwidth of mother wavelet. Defaults to <cite>1</cite>.</p></li>
<li><p><strong>max_order</strong> (<em>int</em><em>, </em><em>optional</em>) – The maximum order of scattering coefficients to compute. Must be
either <cite>1</cite> or <cite>2</cite>. Defaults to <cite>2</cite>.</p></li>
<li><p><strong>rotation_covariant</strong> (<em>bool</em><em>, </em><em>optional</em>) – <p>If set to <cite>True</cite> the first-order moduli take the form:</p>
<p><span class="math notranslate nohighlight">\(\sqrt{\sum_m (x \star \psi_{j,l,m})^2)}\)</span></p>
<p>if set to <cite>False</cite> the first-order moduli take the form:</p>
<p><span class="math notranslate nohighlight">\(x \star \psi_{j,l,m}\)</span></p>
<p>The second order moduli change analogously. Defaults to <cite>True</cite>.</p>
</p></li>
<li><p><strong>method</strong> (<em>string</em><em>, </em><em>optional</em>) – Specifies the method for obtaining scattering coefficients.
Currently, only <cite>‘integral’</cite> is available. Defaults to <cite>‘integral’</cite>.</p></li>
<li><p><strong>integral_powers</strong> (<em>array-like</em>) – List of exponents to the power of which moduli are raised before
integration.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="kymatio.torch.HarmonicScattering3D.build">
<span class="sig-name descname"><span class="pre">build</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#kymatio.torch.HarmonicScattering3D.build" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines elementary routines.</p>
<p>This function should always call and create the filters via
self.create_filters() defined below. For instance, via:
self.filters = self.create_filters()</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="kymatio.torch.HarmonicScattering3D.register_filters">
<span class="sig-name descname"><span class="pre">register_filters</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#kymatio.torch.HarmonicScattering3D.register_filters" title="Permalink to this definition">¶</a></dt>
<dd><p>This function should be called after filters are generated,
saving those arrays as module buffers.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="kymatio.torch.HarmonicScattering3D.scattering">
<span class="sig-name descname"><span class="pre">scattering</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kymatio.torch.HarmonicScattering3D.scattering" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the scattering transform</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>input_array</strong> (<em>torch.Tensor</em>) – Input of size <cite>(batch_size, M, N, O)</cite>.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>output</strong> – If max_order is <cite>1</cite> it returns a <cite>torch.Tensor</cite> with the first-order
scattering coefficients. If max_order is <cite>2</cite> it returns a
<cite>torch.Tensor</cite> with the first- and second- order scattering
coefficients, concatenated along the feature axis.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="kymatio.torch.Scattering1D">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">kymatio.torch.</span></span><span class="sig-name descname"><span class="pre">Scattering1D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">J</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">average</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">oversampling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'array'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'torch'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kymatio.torch.Scattering1D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">ScatteringTorch</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ScatteringBase1D</span></code></p>
<p>The 1D scattering transform</p>
<blockquote>
<div><p>The scattering transform computes a cascade of wavelet transforms
alternated with a complex modulus non-linearity. The scattering
transform of a 1D signal <span class="math notranslate nohighlight">\(x(t)\)</span> may be written as</p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\(S_J x = [S_J^{(0)} x, S_J^{(1)} x, S_J^{(2)} x]\)</span></p>
</div></blockquote>
<p>where</p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\(S_J^{(0)} x(t) = x \star \phi_J(t)\)</span>,</p>
<p><span class="math notranslate nohighlight">\(S_J^{(1)} x(t, \lambda) = |x \star \psi_\lambda^{(1)}| \star \phi_J\)</span>, and</p>
<p><span class="math notranslate nohighlight">\(S_J^{(2)} x(t, \lambda, \mu) = |\,| x \star \psi_\lambda^{(1)}| \star \psi_\mu^{(2)} | \star \phi_J\)</span>.</p>
</div></blockquote>
<p>In the above formulas, <span class="math notranslate nohighlight">\(\star\)</span> denotes convolution in time. The
filters <span class="math notranslate nohighlight">\(\psi_\lambda^{(1)}(t)\)</span> and <span class="math notranslate nohighlight">\(\psi_\mu^{(2)}(t)\)</span> are analytic
wavelets with center frequencies <span class="math notranslate nohighlight">\(\lambda\)</span> and <span class="math notranslate nohighlight">\(\mu\)</span>, while
<span class="math notranslate nohighlight">\(\phi_J(t)\)</span> is a real lowpass filter centered at the zero frequency.</p>
<p>The <cite>Scattering1D</cite> class implements the 1D scattering transform for a
given set of filters whose parameters are specified at initialization.
While the wavelets are fixed, other parameters may be changed after
the object is created, such as whether to compute all of
<span class="math notranslate nohighlight">\(S_J^{(0)} x\)</span>, <span class="math notranslate nohighlight">\(S_J^{(1)} x\)</span>, and <span class="math notranslate nohighlight">\(S_J^{(2)} x\)</span> or just
<span class="math notranslate nohighlight">\(S_J^{(0)} x\)</span> and <span class="math notranslate nohighlight">\(S_J^{(1)} x\)</span>.</p>
<p>This class inherits from <cite>torch.nn.Module</cite>. As a result, it has all
the same capabilities, including transferring the object to the GPU
using the <cite>cuda</cite> or <cite>to</cite> methods. This object would then take GPU
tensors as input and output the scattering coefficients of those
tensors.</p>
<p>Given an input <cite>torch.Tensor</cite> <cite>x</cite> of shape <cite>(B, N)</cite>, where <cite>B</cite> is the
number of signals to transform (the batch size) and <cite>N</cite> is the length
of the signal, we compute its scattering transform by passing it to
the <cite>scattering</cite> method (or calling the alias <cite>forward</cite>). Note
that <cite>B</cite> can be one, in which case it may be omitted, giving an input
of shape <cite>(N,)</cite>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set the parameters of the scattering transform.</span>
<span class="n">J</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">13</span>
<span class="n">Q</span> <span class="o">=</span> <span class="mi">8</span>

<span class="c1"># Generate a sample signal.</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

<span class="c1"># Define a Scattering1D object.</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">Scattering1D</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>

<span class="c1"># Calculate the scattering transform.</span>
<span class="n">Sx</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">scattering</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># Equivalently, use the alias.</span>
<span class="n">Sx</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>Above, the length of the signal is <span class="math notranslate nohighlight">\(N = 2^{13} = 8192\)</span>, while the
maximum scale of the scattering transform is set to <span class="math notranslate nohighlight">\(2^J = 2^6 =
64\)</span>. The time-frequency resolution of the first-order wavelets
<span class="math notranslate nohighlight">\(\psi_\lambda^{(1)}(t)\)</span> is set to <cite>Q = 8</cite> wavelets per octave.
The second-order wavelets <span class="math notranslate nohighlight">\(\psi_\mu^{(2)}(t)\)</span> always have one
wavelet per octave.</p>
<dl class="simple">
<dt>J<span class="classifier">int</span></dt><dd><p>The maximum log-scale of the scattering transform. In other words,
the maximum scale is given by <span class="math notranslate nohighlight">\(2^J\)</span>.</p>
</dd>
<dt>shape<span class="classifier">int</span></dt><dd><p>The length of the input signals.</p>
</dd>
<dt>Q<span class="classifier">int or tuple</span></dt><dd><p>By default, Q (int) is the number of wavelets per octave for the first
order and that for the second order has one wavelet per octave. This
default value can be modified by passing Q as a tuple with two values,
i.e. Q = (Q1, Q2), where Q1 and Q2 are the number of wavelets per
octave for the first and second order, respectively.</p>
</dd>
<dt>T<span class="classifier">int</span></dt><dd><p>temporal support of low-pass filter, controlling amount of imposed
time-shift invariance and maximum subsampling</p>
</dd>
<dt>max_order<span class="classifier">int, optional</span></dt><dd><p>The maximum order of scattering coefficients to compute. Must be
either <cite>1</cite> or <cite>2</cite>. Defaults to <cite>2</cite>.</p>
</dd>
<dt>average<span class="classifier">boolean, optional</span></dt><dd><p>Determines whether the output is averaged in time or not. The
averaged output corresponds to the standard scattering transform,
while the un-averaged output skips the last convolution by
<span class="math notranslate nohighlight">\(\phi_J(t)\)</span>.  This parameter may be modified after object
creation. Defaults to <cite>True</cite>. Deprecated in v0.3 in favour of <cite>T</cite>
and will  be removed in v0.4. Replace <cite>average=False</cite> by <cite>T=0</cite> and
set <cite>T&gt;1</cite> or leave <cite>T=None</cite> for <cite>average=True</cite> (default).</p>
</dd>
<dt>oversampling<span class="classifier">integer &gt;= 0, optional</span></dt><dd><p>Controls the oversampling factor relative to the default as a
power of two. Since the convolving by wavelets (or lowpass
filters) and taking the modulus reduces the high-frequency content
of the signal, we can subsample to save space and improve
performance. However, this may reduce precision in the
calculation. If this is not desirable, <cite>oversampling</cite> can be set
to a large value to prevent too much subsampling. This parameter
may be modified after object creation. Defaults to <cite>0</cite>.</p>
</dd>
<dt>vectorize<span class="classifier">boolean, optional</span></dt><dd><p>Determines wheter to return a vectorized scattering transform
(that is, a large array containing the output) or a dictionary
(where each entry corresponds to a separate scattering
coefficient). This parameter may be modified after object
creation. Deprecated in favor of <cite>out_type</cite> (see below). Defaults
to True.</p>
</dd>
<dt>out_type<span class="classifier">str, optional</span></dt><dd><p>The format of the output of a scattering transform. If set to
<cite>‘list’</cite>, then the output is a list containing each individual
scattering coefficient with meta information. Otherwise, if set to
<cite>‘array’</cite>, the output is a large array containing the
concatenation of all scattering coefficients. Defaults to
<cite>‘array’</cite>.</p>
</dd>
</dl>
<dl class="simple">
<dt>J<span class="classifier">int</span></dt><dd><p>The maximum log-scale of the scattering transform. In other words,
the maximum scale is given by <cite>2 ** J</cite>.</p>
</dd>
<dt>shape<span class="classifier">int</span></dt><dd><p>The length of the input signals.</p>
</dd>
<dt>Q<span class="classifier">int</span></dt><dd><p>The number of first-order wavelets per octave (second-order
wavelets are fixed to one wavelet per octave).</p>
</dd>
<dt>T<span class="classifier">int</span></dt><dd><p>temporal support of low-pass filter, controlling amount of imposed
time-shift invariance and maximum subsampling</p>
</dd>
<dt>pad_left<span class="classifier">int</span></dt><dd><p>The amount of padding to the left of the signal.</p>
</dd>
<dt>pad_right<span class="classifier">int</span></dt><dd><p>The amount of padding to the right of the signal.</p>
</dd>
<dt>phi_f<span class="classifier">dictionary</span></dt><dd><p>A dictionary containing the lowpass filter at all resolutions. See
<cite>filter_bank.scattering_filter_factory</cite> for an exact description.</p>
</dd>
<dt>psi1_f<span class="classifier">dictionary</span></dt><dd><p>A dictionary containing all the first-order wavelet filters, each
represented as a dictionary containing that filter at all
resolutions. See <cite>filter_bank.scattering_filter_factory</cite> for an
exact description.</p>
</dd>
<dt>psi2_f<span class="classifier">dictionary</span></dt><dd><p>A dictionary containing all the second-order wavelet filters, each
represented as a dictionary containing that filter at all
resolutions. See <cite>filter_bank.scattering_filter_factory</cite> for an
exact description.</p>
</dd>
<dt>max_order<span class="classifier">int</span></dt><dd><p>The maximum scattering order of the transform.</p>
</dd>
<dt>average<span class="classifier">boolean</span></dt><dd><p>Controls whether the output should be averaged (the standard
scattering transform) or not (resulting in wavelet modulus
coefficients). Note that to obtain unaveraged output, the
<cite>vectorize</cite> flag must be set to <cite>False</cite> or <cite>out_type</cite> must be set
to <cite>‘list’</cite>. Deprecated in favor of <cite>T</cite>. For more details,
see the documentation for <cite>scattering</cite>.</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>oversampling<span class="classifier">int</span></dt><dd><blockquote>
<div><p>The number of powers of two to oversample the output compared to
the default subsampling rate determined from the filters.</p>
</div></blockquote>
<dl class="simple">
<dt>vectorize<span class="classifier">boolean</span></dt><dd><p>Controls whether the output should be vectorized into a single
Tensor or collected into a dictionary. Deprecated in favor of
<cite>out_type</cite>. For more details, see the documentation for
<cite>scattering</cite>.</p>
</dd>
<dt>out_type<span class="classifier">str</span></dt><dd><p>Specifices the output format of the transform, which is currently
one of <cite>‘array’</cite> or <cite>‘list</cite>’. If <cite>‘array’</cite>, the output is a large
array containing the scattering coefficients. If <cite>‘list</cite>’, the
output is a list of dictionaries, each containing a scattering
coefficient along with meta information. For more information, see
the documentation for <cite>scattering</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="kymatio.torch.Scattering1D.load_filters">
<span class="sig-name descname"><span class="pre">load_filters</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#kymatio.torch.Scattering1D.load_filters" title="Permalink to this definition">¶</a></dt>
<dd><p>This function loads filters from the module’s buffer</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="kymatio.torch.Scattering1D.register_filters">
<span class="sig-name descname"><span class="pre">register_filters</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#kymatio.torch.Scattering1D.register_filters" title="Permalink to this definition">¶</a></dt>
<dd><p>This function run the filterbank function that
will create the filters as numpy array, and then, it
saves those arrays as module’s buffers.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="kymatio.torch.Scattering1D.scattering">
<span class="sig-name descname"><span class="pre">scattering</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kymatio.torch.Scattering1D.scattering" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the scattering transform</p>
<p>Given an input <cite>torch.Tensor</cite> of size <cite>(B, N)</cite>, where <cite>B</cite> is the batch
size (it can be potentially an integer or a shape) and <cite>N</cite> is the length
of the individual signals, this function computes its scattering
transform. If the <cite>vectorize</cite> flag is set to <cite>True</cite> (or if it is not
available in this frontend), the output is in the form of a <cite>torch.Tensor</cite>
or size <cite>(B, C, N1)</cite>, where <cite>N1</cite> is the signal length after subsampling
to the scale <span class="math notranslate nohighlight">\(2^J\)</span> (with the appropriate oversampling factor to
reduce aliasing), and <cite>C</cite> is the number of scattering coefficients. If
<cite>vectorize</cite> is set <cite>False</cite>, however, the output is a dictionary
containing <cite>C</cite> keys, each a tuple whose length corresponds to the
scattering order and whose elements are the sequence of filter indices
used.</p>
<p>Note that the <cite>vectorize</cite> flag has been deprecated in favor of the
<cite>out_type</cite> parameter. If this is set to <cite>‘array’</cite> (the default), the
<cite>vectorize</cite> flag is still respected, but if not, <cite>out_type</cite> takes
precedence. The two current output types are <cite>‘array’</cite> and <cite>‘list’</cite>.
The former gives the type of output described above. If set to
<cite>‘list’</cite>, however, the output is a list of dictionaries, each
dictionary corresponding to a scattering coefficient and its associated
meta information. The coefficient is stored under the <cite>‘coef’</cite> key,
while other keys contain additional information, such as <cite>‘j’</cite> (the
scale of the filter used) and <cite>‘n</cite>’ (the filter index).</p>
<p>Furthermore, if the <cite>average</cite> flag is set to <cite>False</cite>, these outputs
are not averaged, but are simply the wavelet modulus coefficients of
the filters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<em>torch.Tensor</em>) – An input <cite>torch.Tensor</cite> of size <cite>(B, N)</cite>.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>S</strong> – If <cite>out_type</cite> is <cite>‘array’</cite> and the <cite>vectorize</cite> flag is <cite>True</cite>, the
output is a <cite>torch.Tensor</cite> containing the scattering coefficients,
while if <cite>vectorize</cite> is <cite>False</cite>, it is a dictionary indexed by
tuples of filter indices. If <cite>out_type</cite> is <cite>‘list’</cite>, the output is
a list of dictionaries as described above.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tensor or dictionary</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="kymatio.torch.Scattering2D">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">kymatio.torch.</span></span><span class="sig-name descname"><span class="pre">Scattering2D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">J</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">L</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_pad</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'torch'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'array'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kymatio.torch.Scattering2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">ScatteringTorch</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ScatteringBase2D</span></code></p>
<p>The 2D scattering transform</p>
<p>The scattering transform computes two wavelet transform
followed by modulus non-linearity. It can be summarized as</p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\(S_J x = [S_J^{(0)} x, S_J^{(1)} x, S_J^{(2)} x]\)</span></p>
</div></blockquote>
<p>where</p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\(S_J^{(0)} x = x \star \phi_J\)</span>,</p>
<p><span class="math notranslate nohighlight">\(S_J^{(1)} x = [|x \star \psi^{(1)}_\lambda| \star \phi_J]_\lambda\)</span>, and</p>
<p><span class="math notranslate nohighlight">\(S_J^{(2)} x = [||x \star \psi^{(1)}_\lambda| \star
\psi^{(2)}_\mu| \star \phi_J]_{\lambda, \mu}\)</span>.</p>
</div></blockquote>
<p>where <span class="math notranslate nohighlight">\(\star\)</span> denotes the convolution (in space), <span class="math notranslate nohighlight">\(\phi_J\)</span> is a
lowpass filter, <span class="math notranslate nohighlight">\(\psi^{(1)}_\lambda\)</span> is a family of bandpass filters
and <span class="math notranslate nohighlight">\(\psi^{(2)}_\mu\)</span> is another family of bandpass filters. Only
Morlet filters are used in this implementation. Convolutions are
efficiently performed in the Fourier domain.</p>
<p>This class inherits from <cite>torch.nn.Module</cite>. As a result, it has all
the same capabilities, including transferring the object to the GPU
using the <cite>cuda</cite> or <cite>to</cite> methods. This object would then take GPU
tensors as input and output the scattering coefficients of those
tensors.</p>
<p class="rubric">Example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set the parameters of the scattering transform.</span>
<span class="n">J</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">M</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span>

<span class="c1"># Generate a sample signal.</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>

<span class="c1"># Define a Scattering2D object.</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">Scattering2D</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>

<span class="c1"># Calculate the scattering transform.</span>
<span class="n">Sx</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">scattering</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># Equivalently, use the alias.</span>
<span class="n">Sx</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>J</strong> (<em>int</em>) – Log-2 of the scattering scale.</p></li>
<li><p><strong>shape</strong> (<em>tuple of ints</em>) – Spatial support (M, N) of the input</p></li>
<li><p><strong>L</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of angles used for the wavelet transform. Defaults to <cite>8</cite>.</p></li>
<li><p><strong>max_order</strong> (<em>int</em><em>, </em><em>optional</em>) – The maximum order of scattering coefficients to compute. Must be
either <cite>1</cite> or <cite>2</cite>. Defaults to <cite>2</cite>.</p></li>
<li><p><strong>pre_pad</strong> (<em>boolean</em><em>, </em><em>optional</em>) – Controls the padding: if set to False, a symmetric padding is
applied on the signal. If set to True, the software will assume
the signal was padded externally. Defaults to <cite>False</cite>.</p></li>
<li><p><strong>backend</strong> (<em>object</em><em>, </em><em>optional</em>) – Controls the backend which is combined with the frontend.</p></li>
<li><p><strong>out_type</strong> (<em>str</em><em>, </em><em>optional</em>) – The format of the output of a scattering transform. If set to
<cite>‘list’</cite>, then the output is a list containing each individual
scattering path with meta information. Otherwise, if set to
<cite>‘array’</cite>, the output is a large array containing the
concatenation of all scattering coefficients. Defaults to
<cite>‘array’</cite>.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.torch.Scattering2D.J">
<span class="sig-name descname"><span class="pre">J</span></span><a class="headerlink" href="#kymatio.torch.Scattering2D.J" title="Permalink to this definition">¶</a></dt>
<dd><p>Log-2 of the scattering scale.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.torch.Scattering2D.shape">
<span class="sig-name descname"><span class="pre">shape</span></span><a class="headerlink" href="#kymatio.torch.Scattering2D.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Spatial support (M, N) of the input</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple of ints</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.torch.Scattering2D.L">
<span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#kymatio.torch.Scattering2D.L" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of angles used for the wavelet transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int, optional</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.torch.Scattering2D.max_order">
<span class="sig-name descname"><span class="pre">max_order</span></span><a class="headerlink" href="#kymatio.torch.Scattering2D.max_order" title="Permalink to this definition">¶</a></dt>
<dd><p>The maximum order of scattering coefficients to compute.
Must be either <cite>1</cite> or <cite>2</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int, optional</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.torch.Scattering2D.pre_pad">
<span class="sig-name descname"><span class="pre">pre_pad</span></span><a class="headerlink" href="#kymatio.torch.Scattering2D.pre_pad" title="Permalink to this definition">¶</a></dt>
<dd><p>Controls the padding: if set to False, a symmetric padding is
applied on the signal. If set to True, the software will assume
the signal was padded externally.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>boolean</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.torch.Scattering2D.Psi">
<span class="sig-name descname"><span class="pre">Psi</span></span><a class="headerlink" href="#kymatio.torch.Scattering2D.Psi" title="Permalink to this definition">¶</a></dt>
<dd><p>Contains the wavelets filters at all resolutions. See
<cite>filter_bank.filter_bank</cite> for an exact description.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.torch.Scattering2D.Phi">
<span class="sig-name descname"><span class="pre">Phi</span></span><a class="headerlink" href="#kymatio.torch.Scattering2D.Phi" title="Permalink to this definition">¶</a></dt>
<dd><p>Contains the low-pass filters at all resolutions. See
<cite>filter_bank.filter_bank</cite> for an exact description.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">M_padded,</span> <span class="pre">N_padded</span></span></dt>
<dd><p>Spatial support of the padded input.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.torch.Scattering2D.out_type">
<span class="sig-name descname"><span class="pre">out_type</span></span><a class="headerlink" href="#kymatio.torch.Scattering2D.out_type" title="Permalink to this definition">¶</a></dt>
<dd><p>The format of the scattering output. See documentation for
<cite>out_type</cite> parameter above and the documentation for <cite>scattering</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Notes</p>
<p>The design of the filters is optimized for the value <cite>L = 8</cite>.</p>
<p>The <cite>pre_pad</cite> flag is particularly useful when cropping bigger images
because this does not introduce border effects inherent to padding.</p>
<dl class="py method">
<dt class="sig sig-object py" id="kymatio.torch.Scattering2D.load_filters">
<span class="sig-name descname"><span class="pre">load_filters</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#kymatio.torch.Scattering2D.load_filters" title="Permalink to this definition">¶</a></dt>
<dd><p>This function loads filters from the module’s buffers</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="kymatio.torch.Scattering2D.register_filters">
<span class="sig-name descname"><span class="pre">register_filters</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#kymatio.torch.Scattering2D.register_filters" title="Permalink to this definition">¶</a></dt>
<dd><p>This function run the filterbank function that
will create the filters as numpy array, and then, it
saves those arrays as module’s buffers.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="kymatio.torch.Scattering2D.scattering">
<span class="sig-name descname"><span class="pre">scattering</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kymatio.torch.Scattering2D.scattering" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the scattering transform</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>input</strong> (<em>torch.Tensor</em>) – An input <cite>torch.Tensor</cite> of size <cite>(B, M, N)</cite>.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError</strong> – In the event that the input does not have at least two dimensions,
or the tensor is not contiguous, or the tensor is not of the
correct spatial size, padded or not.</p></li>
<li><p><strong>TypeError</strong> – In the event that the input is not of type <cite>torch.Tensor</cite>.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>S</strong> – Scattering transform of the input. If <cite>out_type</cite> is set to
<cite>‘array’</cite> (or if it is not availabel for this frontend), this is
a <cite>torch.Tensor</cite> of shape <cite>(B, C, M1, N1)</cite> where <cite>M1 = M // 2 ** J</cite>
and <cite>N1 = N // 2 ** J</cite>. The <cite>C</cite> is the number of scattering
channels calculated. If <cite>out_type</cite> is <cite>‘list’</cite>, the output is a
list of dictionaries, with each dictionary corresponding to a
scattering coefficient and its meta information. The actual
coefficient is contained in the <cite>‘coef’</cite> key, while other keys hold
additional information, such as <cite>‘j’</cite> (the scale of the filter
used), and <cite>‘theta’</cite> (the angle index of the filter used).</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-kymatio.tensorflow">
<span id="tensorflow"></span><h2>TensorFlow<a class="headerlink" href="#module-kymatio.tensorflow" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="kymatio.tensorflow.HarmonicScattering3D">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">kymatio.tensorflow.</span></span><span class="sig-name descname"><span class="pre">HarmonicScattering3D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kymatio.tensorflow.HarmonicScattering3D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">ScatteringTensorFlow</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ScatteringBase3D</span></code></p>
<p>The 3D solid harmonic scattering transform</p>
<p>This class implements solid harmonic scattering on a 3D input image.
For details see <a class="reference external" href="https://arxiv.org/abs/1805.00571">https://arxiv.org/abs/1805.00571</a>.</p>
<p>This class inherits from <cite>tf.Module</cite>. As a result, it has all the
same capabilities as a standard TensorFlow <cite>Module</cite>.</p>
<p class="rubric">Example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set the parameters of the scattering transform.</span>
<span class="n">J</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">O</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span>

<span class="c1"># Generate a sample signal.</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">O</span><span class="p">)</span>

<span class="c1"># Define a HarmonicScattering3D object.</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">HarmonicScattering3D</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">O</span><span class="p">))</span>

<span class="c1"># Calculate the scattering transform.</span>
<span class="n">Sx</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">scattering</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># Equivalently, use the alias.</span>
<span class="n">Sx</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>J</strong> (<em>int</em>) – Number of scales.</p></li>
<li><p><strong>shape</strong> (<em>tuple of ints</em>) – Shape <cite>(M, N, O)</cite> of the input signal</p></li>
<li><p><strong>L</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of <cite>l</cite> values. Defaults to <cite>3</cite>.</p></li>
<li><p><strong>sigma_0</strong> (<em>float</em><em>, </em><em>optional</em>) – Bandwidth of mother wavelet. Defaults to <cite>1</cite>.</p></li>
<li><p><strong>max_order</strong> (<em>int</em><em>, </em><em>optional</em>) – The maximum order of scattering coefficients to compute. Must be
either <cite>1</cite> or <cite>2</cite>. Defaults to <cite>2</cite>.</p></li>
<li><p><strong>rotation_covariant</strong> (<em>bool</em><em>, </em><em>optional</em>) – <p>If set to <cite>True</cite> the first-order moduli take the form:</p>
<p><span class="math notranslate nohighlight">\(\sqrt{\sum_m (x \star \psi_{j,l,m})^2)}\)</span></p>
<p>if set to <cite>False</cite> the first-order moduli take the form:</p>
<p><span class="math notranslate nohighlight">\(x \star \psi_{j,l,m}\)</span></p>
<p>The second order moduli change analogously. Defaults to <cite>True</cite>.</p>
</p></li>
<li><p><strong>method</strong> (<em>string</em><em>, </em><em>optional</em>) – Specifies the method for obtaining scattering coefficients.
Currently, only <cite>‘integral’</cite> is available. Defaults to <cite>‘integral’</cite>.</p></li>
<li><p><strong>integral_powers</strong> (<em>array-like</em>) – List of exponents to the power of which moduli are raised before
integration.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="kymatio.tensorflow.HarmonicScattering3D.build">
<span class="sig-name descname"><span class="pre">build</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#kymatio.tensorflow.HarmonicScattering3D.build" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines elementary routines.</p>
<p>This function should always call and create the filters via
self.create_filters() defined below. For instance, via:
self.filters = self.create_filters()</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="kymatio.tensorflow.HarmonicScattering3D.scattering">
<span class="sig-name descname"><span class="pre">scattering</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kymatio.tensorflow.HarmonicScattering3D.scattering" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the scattering transform</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>input_array</strong> (<em>tf.Tensor</em>) – Input of size <cite>(batch_size, M, N, O)</cite>.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>output</strong> – If max_order is <cite>1</cite> it returns a <cite>tf.Tensor</cite> with the first-order
scattering coefficients. If max_order is <cite>2</cite> it returns a
<cite>tf.Tensor</cite> with the first- and second- order scattering
coefficients, concatenated along the feature axis.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tf.Tensor</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="kymatio.tensorflow.Scattering1D">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">kymatio.tensorflow.</span></span><span class="sig-name descname"><span class="pre">Scattering1D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kymatio.tensorflow.Scattering1D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">ScatteringTensorFlow</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ScatteringBase1D</span></code></p>
<p>The 1D scattering transform</p>
<blockquote>
<div><p>The scattering transform computes a cascade of wavelet transforms
alternated with a complex modulus non-linearity. The scattering
transform of a 1D signal <span class="math notranslate nohighlight">\(x(t)\)</span> may be written as</p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\(S_J x = [S_J^{(0)} x, S_J^{(1)} x, S_J^{(2)} x]\)</span></p>
</div></blockquote>
<p>where</p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\(S_J^{(0)} x(t) = x \star \phi_J(t)\)</span>,</p>
<p><span class="math notranslate nohighlight">\(S_J^{(1)} x(t, \lambda) = |x \star \psi_\lambda^{(1)}| \star \phi_J\)</span>, and</p>
<p><span class="math notranslate nohighlight">\(S_J^{(2)} x(t, \lambda, \mu) = |\,| x \star \psi_\lambda^{(1)}| \star \psi_\mu^{(2)} | \star \phi_J\)</span>.</p>
</div></blockquote>
<p>In the above formulas, <span class="math notranslate nohighlight">\(\star\)</span> denotes convolution in time. The
filters <span class="math notranslate nohighlight">\(\psi_\lambda^{(1)}(t)\)</span> and <span class="math notranslate nohighlight">\(\psi_\mu^{(2)}(t)\)</span> are analytic
wavelets with center frequencies <span class="math notranslate nohighlight">\(\lambda\)</span> and <span class="math notranslate nohighlight">\(\mu\)</span>, while
<span class="math notranslate nohighlight">\(\phi_J(t)\)</span> is a real lowpass filter centered at the zero frequency.</p>
<p>The <cite>Scattering1D</cite> class implements the 1D scattering transform for a
given set of filters whose parameters are specified at initialization.
While the wavelets are fixed, other parameters may be changed after
the object is created, such as whether to compute all of
<span class="math notranslate nohighlight">\(S_J^{(0)} x\)</span>, <span class="math notranslate nohighlight">\(S_J^{(1)} x\)</span>, and <span class="math notranslate nohighlight">\(S_J^{(2)} x\)</span> or just
<span class="math notranslate nohighlight">\(S_J^{(0)} x\)</span> and <span class="math notranslate nohighlight">\(S_J^{(1)} x\)</span>.</p>
<p>This class inherits from <cite>tf.Module</cite>. As a result, it has all the
same capabilities as a standard TensorFlow <cite>Module</cite>.</p>
<p>Given an input <cite>tf.Tensor</cite> <cite>x</cite> of shape <cite>(B, N)</cite>, where <cite>B</cite> is the
number of signals to transform (the batch size) and <cite>N</cite> is the length
of the signal, we compute its scattering transform by passing it to
the <cite>scattering</cite> method (or calling the alias <cite>__call__</cite>). Note
that <cite>B</cite> can be one, in which case it may be omitted, giving an input
of shape <cite>(N,)</cite>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set the parameters of the scattering transform.</span>
<span class="n">J</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">13</span>
<span class="n">Q</span> <span class="o">=</span> <span class="mi">8</span>

<span class="c1"># Generate a sample signal.</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

<span class="c1"># Define a Scattering1D object.</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">Scattering1D</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>

<span class="c1"># Calculate the scattering transform.</span>
<span class="n">Sx</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">scattering</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># Equivalently, use the alias.</span>
<span class="n">Sx</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>Above, the length of the signal is <span class="math notranslate nohighlight">\(N = 2^{13} = 8192\)</span>, while the
maximum scale of the scattering transform is set to <span class="math notranslate nohighlight">\(2^J = 2^6 =
64\)</span>. The time-frequency resolution of the first-order wavelets
<span class="math notranslate nohighlight">\(\psi_\lambda^{(1)}(t)\)</span> is set to <cite>Q = 8</cite> wavelets per octave.
The second-order wavelets <span class="math notranslate nohighlight">\(\psi_\mu^{(2)}(t)\)</span> always have one
wavelet per octave.</p>
<dl class="simple">
<dt>J<span class="classifier">int</span></dt><dd><p>The maximum log-scale of the scattering transform. In other words,
the maximum scale is given by <span class="math notranslate nohighlight">\(2^J\)</span>.</p>
</dd>
<dt>shape<span class="classifier">int</span></dt><dd><p>The length of the input signals.</p>
</dd>
<dt>Q<span class="classifier">int or tuple</span></dt><dd><p>By default, Q (int) is the number of wavelets per octave for the first
order and that for the second order has one wavelet per octave. This
default value can be modified by passing Q as a tuple with two values,
i.e. Q = (Q1, Q2), where Q1 and Q2 are the number of wavelets per
octave for the first and second order, respectively.</p>
</dd>
<dt>T<span class="classifier">int</span></dt><dd><p>temporal support of low-pass filter, controlling amount of imposed
time-shift invariance and maximum subsampling</p>
</dd>
<dt>max_order<span class="classifier">int, optional</span></dt><dd><p>The maximum order of scattering coefficients to compute. Must be
either <cite>1</cite> or <cite>2</cite>. Defaults to <cite>2</cite>.</p>
</dd>
<dt>average<span class="classifier">boolean, optional</span></dt><dd><p>Determines whether the output is averaged in time or not. The
averaged output corresponds to the standard scattering transform,
while the un-averaged output skips the last convolution by
<span class="math notranslate nohighlight">\(\phi_J(t)\)</span>.  This parameter may be modified after object
creation. Defaults to <cite>True</cite>. Deprecated in v0.3 in favour of <cite>T</cite>
and will  be removed in v0.4. Replace <cite>average=False</cite> by <cite>T=0</cite> and
set <cite>T&gt;1</cite> or leave <cite>T=None</cite> for <cite>average=True</cite> (default).</p>
</dd>
<dt>oversampling<span class="classifier">integer &gt;= 0, optional</span></dt><dd><p>Controls the oversampling factor relative to the default as a
power of two. Since the convolving by wavelets (or lowpass
filters) and taking the modulus reduces the high-frequency content
of the signal, we can subsample to save space and improve
performance. However, this may reduce precision in the
calculation. If this is not desirable, <cite>oversampling</cite> can be set
to a large value to prevent too much subsampling. This parameter
may be modified after object creation. Defaults to <cite>0</cite>.</p>
</dd>
<dt>vectorize<span class="classifier">boolean, optional</span></dt><dd><p>Determines wheter to return a vectorized scattering transform
(that is, a large array containing the output) or a dictionary
(where each entry corresponds to a separate scattering
coefficient). This parameter may be modified after object
creation. Deprecated in favor of <cite>out_type</cite> (see below). Defaults
to True.</p>
</dd>
<dt>out_type<span class="classifier">str, optional</span></dt><dd><p>The format of the output of a scattering transform. If set to
<cite>‘list’</cite>, then the output is a list containing each individual
scattering coefficient with meta information. Otherwise, if set to
<cite>‘array’</cite>, the output is a large array containing the
concatenation of all scattering coefficients. Defaults to
<cite>‘array’</cite>.</p>
</dd>
</dl>
<dl class="simple">
<dt>J<span class="classifier">int</span></dt><dd><p>The maximum log-scale of the scattering transform. In other words,
the maximum scale is given by <cite>2 ** J</cite>.</p>
</dd>
<dt>shape<span class="classifier">int</span></dt><dd><p>The length of the input signals.</p>
</dd>
<dt>Q<span class="classifier">int</span></dt><dd><p>The number of first-order wavelets per octave (second-order
wavelets are fixed to one wavelet per octave).</p>
</dd>
<dt>T<span class="classifier">int</span></dt><dd><p>temporal support of low-pass filter, controlling amount of imposed
time-shift invariance and maximum subsampling</p>
</dd>
<dt>pad_left<span class="classifier">int</span></dt><dd><p>The amount of padding to the left of the signal.</p>
</dd>
<dt>pad_right<span class="classifier">int</span></dt><dd><p>The amount of padding to the right of the signal.</p>
</dd>
<dt>phi_f<span class="classifier">dictionary</span></dt><dd><p>A dictionary containing the lowpass filter at all resolutions. See
<cite>filter_bank.scattering_filter_factory</cite> for an exact description.</p>
</dd>
<dt>psi1_f<span class="classifier">dictionary</span></dt><dd><p>A dictionary containing all the first-order wavelet filters, each
represented as a dictionary containing that filter at all
resolutions. See <cite>filter_bank.scattering_filter_factory</cite> for an
exact description.</p>
</dd>
<dt>psi2_f<span class="classifier">dictionary</span></dt><dd><p>A dictionary containing all the second-order wavelet filters, each
represented as a dictionary containing that filter at all
resolutions. See <cite>filter_bank.scattering_filter_factory</cite> for an
exact description.</p>
</dd>
<dt>max_order<span class="classifier">int</span></dt><dd><p>The maximum scattering order of the transform.</p>
</dd>
<dt>average<span class="classifier">boolean</span></dt><dd><p>Controls whether the output should be averaged (the standard
scattering transform) or not (resulting in wavelet modulus
coefficients). Note that to obtain unaveraged output, the
<cite>vectorize</cite> flag must be set to <cite>False</cite> or <cite>out_type</cite> must be set
to <cite>‘list’</cite>. Deprecated in favor of <cite>T</cite>. For more details,
see the documentation for <cite>scattering</cite>.</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>oversampling<span class="classifier">int</span></dt><dd><blockquote>
<div><p>The number of powers of two to oversample the output compared to
the default subsampling rate determined from the filters.</p>
</div></blockquote>
<dl class="simple">
<dt>vectorize<span class="classifier">boolean</span></dt><dd><p>Controls whether the output should be vectorized into a single
Tensor or collected into a dictionary. Deprecated in favor of
<cite>out_type</cite>. For more details, see the documentation for
<cite>scattering</cite>.</p>
</dd>
<dt>out_type<span class="classifier">str</span></dt><dd><p>Specifices the output format of the transform, which is currently
one of <cite>‘array’</cite> or <cite>‘list</cite>’. If <cite>‘array’</cite>, the output is a large
array containing the scattering coefficients. If <cite>‘list</cite>’, the
output is a list of dictionaries, each containing a scattering
coefficient along with meta information. For more information, see
the documentation for <cite>scattering</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="kymatio.tensorflow.Scattering1D.scattering">
<span class="sig-name descname"><span class="pre">scattering</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kymatio.tensorflow.Scattering1D.scattering" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the scattering transform</p>
<p>Given an input <cite>tf.Tensor</cite> of size <cite>(B, N)</cite>, where <cite>B</cite> is the batch
size (it can be potentially an integer or a shape) and <cite>N</cite> is the length
of the individual signals, this function computes its scattering
transform. If the <cite>vectorize</cite> flag is set to <cite>True</cite> (or if it is not
available in this frontend), the output is in the form of a <cite>tf.Tensor</cite>
or size <cite>(B, C, N1)</cite>, where <cite>N1</cite> is the signal length after subsampling
to the scale <span class="math notranslate nohighlight">\(2^J\)</span> (with the appropriate oversampling factor to
reduce aliasing), and <cite>C</cite> is the number of scattering coefficients. If
<cite>vectorize</cite> is set <cite>False</cite>, however, the output is a dictionary
containing <cite>C</cite> keys, each a tuple whose length corresponds to the
scattering order and whose elements are the sequence of filter indices
used.</p>
<p>Note that the <cite>vectorize</cite> flag has been deprecated in favor of the
<cite>out_type</cite> parameter. If this is set to <cite>‘array’</cite> (the default), the
<cite>vectorize</cite> flag is still respected, but if not, <cite>out_type</cite> takes
precedence. The two current output types are <cite>‘array’</cite> and <cite>‘list’</cite>.
The former gives the type of output described above. If set to
<cite>‘list’</cite>, however, the output is a list of dictionaries, each
dictionary corresponding to a scattering coefficient and its associated
meta information. The coefficient is stored under the <cite>‘coef’</cite> key,
while other keys contain additional information, such as <cite>‘j’</cite> (the
scale of the filter used) and <cite>‘n</cite>’ (the filter index).</p>
<p>Furthermore, if the <cite>average</cite> flag is set to <cite>False</cite>, these outputs
are not averaged, but are simply the wavelet modulus coefficients of
the filters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<em>tf.Tensor</em>) – An input <cite>tf.Tensor</cite> of size <cite>(B, N)</cite>.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>S</strong> – If <cite>out_type</cite> is <cite>‘array’</cite> and the <cite>vectorize</cite> flag is <cite>True</cite>, the
output is a <cite>tf.Tensor</cite> containing the scattering coefficients,
while if <cite>vectorize</cite> is <cite>False</cite>, it is a dictionary indexed by
tuples of filter indices. If <cite>out_type</cite> is <cite>‘list’</cite>, the output is
a list of dictionaries as described above.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tensor or dictionary</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="kymatio.tensorflow.Scattering2D">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">kymatio.tensorflow.</span></span><span class="sig-name descname"><span class="pre">Scattering2D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kymatio.tensorflow.Scattering2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">ScatteringTensorFlow</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ScatteringBase2D</span></code></p>
<p>The 2D scattering transform</p>
<p>The scattering transform computes two wavelet transform
followed by modulus non-linearity. It can be summarized as</p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\(S_J x = [S_J^{(0)} x, S_J^{(1)} x, S_J^{(2)} x]\)</span></p>
</div></blockquote>
<p>where</p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\(S_J^{(0)} x = x \star \phi_J\)</span>,</p>
<p><span class="math notranslate nohighlight">\(S_J^{(1)} x = [|x \star \psi^{(1)}_\lambda| \star \phi_J]_\lambda\)</span>, and</p>
<p><span class="math notranslate nohighlight">\(S_J^{(2)} x = [||x \star \psi^{(1)}_\lambda| \star
\psi^{(2)}_\mu| \star \phi_J]_{\lambda, \mu}\)</span>.</p>
</div></blockquote>
<p>where <span class="math notranslate nohighlight">\(\star\)</span> denotes the convolution (in space), <span class="math notranslate nohighlight">\(\phi_J\)</span> is a
lowpass filter, <span class="math notranslate nohighlight">\(\psi^{(1)}_\lambda\)</span> is a family of bandpass filters
and <span class="math notranslate nohighlight">\(\psi^{(2)}_\mu\)</span> is another family of bandpass filters. Only
Morlet filters are used in this implementation. Convolutions are
efficiently performed in the Fourier domain.</p>
<p>This class inherits from <cite>tf.Module</cite>. As a result, it has all the
same capabilities as a standard TensorFlow <cite>Module</cite>.</p>
<p class="rubric">Example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set the parameters of the scattering transform.</span>
<span class="n">J</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">M</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span>

<span class="c1"># Generate a sample signal.</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>

<span class="c1"># Define a Scattering2D object.</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">Scattering2D</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>

<span class="c1"># Calculate the scattering transform.</span>
<span class="n">Sx</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">scattering</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># Equivalently, use the alias.</span>
<span class="n">Sx</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>J</strong> (<em>int</em>) – Log-2 of the scattering scale.</p></li>
<li><p><strong>shape</strong> (<em>tuple of ints</em>) – Spatial support (M, N) of the input</p></li>
<li><p><strong>L</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of angles used for the wavelet transform. Defaults to <cite>8</cite>.</p></li>
<li><p><strong>max_order</strong> (<em>int</em><em>, </em><em>optional</em>) – The maximum order of scattering coefficients to compute. Must be
either <cite>1</cite> or <cite>2</cite>. Defaults to <cite>2</cite>.</p></li>
<li><p><strong>pre_pad</strong> (<em>boolean</em><em>, </em><em>optional</em>) – Controls the padding: if set to False, a symmetric padding is
applied on the signal. If set to True, the software will assume
the signal was padded externally. Defaults to <cite>False</cite>.</p></li>
<li><p><strong>backend</strong> (<em>object</em><em>, </em><em>optional</em>) – Controls the backend which is combined with the frontend.</p></li>
<li><p><strong>out_type</strong> (<em>str</em><em>, </em><em>optional</em>) – The format of the output of a scattering transform. If set to
<cite>‘list’</cite>, then the output is a list containing each individual
scattering path with meta information. Otherwise, if set to
<cite>‘array’</cite>, the output is a large array containing the
concatenation of all scattering coefficients. Defaults to
<cite>‘array’</cite>.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.tensorflow.Scattering2D.J">
<span class="sig-name descname"><span class="pre">J</span></span><a class="headerlink" href="#kymatio.tensorflow.Scattering2D.J" title="Permalink to this definition">¶</a></dt>
<dd><p>Log-2 of the scattering scale.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.tensorflow.Scattering2D.shape">
<span class="sig-name descname"><span class="pre">shape</span></span><a class="headerlink" href="#kymatio.tensorflow.Scattering2D.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Spatial support (M, N) of the input</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple of ints</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.tensorflow.Scattering2D.L">
<span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#kymatio.tensorflow.Scattering2D.L" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of angles used for the wavelet transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int, optional</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.tensorflow.Scattering2D.max_order">
<span class="sig-name descname"><span class="pre">max_order</span></span><a class="headerlink" href="#kymatio.tensorflow.Scattering2D.max_order" title="Permalink to this definition">¶</a></dt>
<dd><p>The maximum order of scattering coefficients to compute.
Must be either <cite>1</cite> or <cite>2</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int, optional</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.tensorflow.Scattering2D.pre_pad">
<span class="sig-name descname"><span class="pre">pre_pad</span></span><a class="headerlink" href="#kymatio.tensorflow.Scattering2D.pre_pad" title="Permalink to this definition">¶</a></dt>
<dd><p>Controls the padding: if set to False, a symmetric padding is
applied on the signal. If set to True, the software will assume
the signal was padded externally.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>boolean</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.tensorflow.Scattering2D.Psi">
<span class="sig-name descname"><span class="pre">Psi</span></span><a class="headerlink" href="#kymatio.tensorflow.Scattering2D.Psi" title="Permalink to this definition">¶</a></dt>
<dd><p>Contains the wavelets filters at all resolutions. See
<cite>filter_bank.filter_bank</cite> for an exact description.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.tensorflow.Scattering2D.Phi">
<span class="sig-name descname"><span class="pre">Phi</span></span><a class="headerlink" href="#kymatio.tensorflow.Scattering2D.Phi" title="Permalink to this definition">¶</a></dt>
<dd><p>Contains the low-pass filters at all resolutions. See
<cite>filter_bank.filter_bank</cite> for an exact description.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">M_padded,</span> <span class="pre">N_padded</span></span></dt>
<dd><p>Spatial support of the padded input.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.tensorflow.Scattering2D.out_type">
<span class="sig-name descname"><span class="pre">out_type</span></span><a class="headerlink" href="#kymatio.tensorflow.Scattering2D.out_type" title="Permalink to this definition">¶</a></dt>
<dd><p>The format of the scattering output. See documentation for
<cite>out_type</cite> parameter above and the documentation for <cite>scattering</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Notes</p>
<p>The design of the filters is optimized for the value <cite>L = 8</cite>.</p>
<p>The <cite>pre_pad</cite> flag is particularly useful when cropping bigger images
because this does not introduce border effects inherent to padding.</p>
<dl class="py method">
<dt class="sig sig-object py" id="kymatio.tensorflow.Scattering2D.scattering">
<span class="sig-name descname"><span class="pre">scattering</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kymatio.tensorflow.Scattering2D.scattering" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the scattering transform</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>input</strong> (<em>tf.Tensor</em>) – An input <cite>tf.Tensor</cite> of size <cite>(B, M, N)</cite>.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError</strong> – In the event that the input does not have at least two dimensions,
or the tensor is not contiguous, or the tensor is not of the
correct spatial size, padded or not.</p></li>
<li><p><strong>TypeError</strong> – In the event that the input is not of type <cite>tf.Tensor</cite>.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>S</strong> – Scattering transform of the input. If <cite>out_type</cite> is set to
<cite>‘array’</cite> (or if it is not availabel for this frontend), this is
a <cite>tf.Tensor</cite> of shape <cite>(B, C, M1, N1)</cite> where <cite>M1 = M // 2 ** J</cite>
and <cite>N1 = N // 2 ** J</cite>. The <cite>C</cite> is the number of scattering
channels calculated. If <cite>out_type</cite> is <cite>‘list’</cite>, the output is a
list of dictionaries, with each dictionary corresponding to a
scattering coefficient and its meta information. The actual
coefficient is contained in the <cite>‘coef’</cite> key, while other keys hold
additional information, such as <cite>‘j’</cite> (the scale of the filter
used), and <cite>‘theta’</cite> (the angle index of the filter used).</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>tf.Tensor</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-kymatio.keras">
<span id="keras"></span><h2>Keras<a class="headerlink" href="#module-kymatio.keras" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="kymatio.keras.Scattering1D">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">kymatio.keras.</span></span><span class="sig-name descname"><span class="pre">Scattering1D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kymatio.keras.Scattering1D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">ScatteringKeras</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ScatteringBase1D</span></code></p>
<p>The 1D scattering transform</p>
<p>The scattering transform computes a cascade of wavelet transforms
alternated with a complex modulus non-linearity. The scattering
transform of a 1D signal <span class="math notranslate nohighlight">\(x(t)\)</span> may be written as</p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\(S_J x = [S_J^{(0)} x, S_J^{(1)} x, S_J^{(2)} x]\)</span></p>
</div></blockquote>
<p>where</p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\(S_J^{(0)} x(t) = x \star \phi_J(t)\)</span>,</p>
<p><span class="math notranslate nohighlight">\(S_J^{(1)} x(t, \lambda) = |x \star \psi_\lambda^{(1)}| \star \phi_J\)</span>, and</p>
<p><span class="math notranslate nohighlight">\(S_J^{(2)} x(t, \lambda, \mu) = |\,| x \star \psi_\lambda^{(1)}| \star \psi_\mu^{(2)} | \star \phi_J\)</span>.</p>
</div></blockquote>
<p>In the above formulas, <span class="math notranslate nohighlight">\(\star\)</span> denotes convolution in time. The
filters <span class="math notranslate nohighlight">\(\psi_\lambda^{(1)}(t)\)</span> and <span class="math notranslate nohighlight">\(\psi_\mu^{(2)}(t)\)</span> are analytic
wavelets with center frequencies <span class="math notranslate nohighlight">\(\lambda\)</span> and <span class="math notranslate nohighlight">\(\mu\)</span>, while
<span class="math notranslate nohighlight">\(\phi_J(t)\)</span> is a real lowpass filter centered at the zero frequency.</p>
<p>The <cite>Scattering1D</cite> class implements the 1D scattering transform for a
given set of filters whose parameters are specified at initialization.
While the wavelets are fixed, other parameters may be changed after
the object is created, such as whether to compute all of
<span class="math notranslate nohighlight">\(S_J^{(0)} x\)</span>, <span class="math notranslate nohighlight">\(S_J^{(1)} x\)</span>, and <span class="math notranslate nohighlight">\(S_J^{(2)} x\)</span> or just
<span class="math notranslate nohighlight">\(S_J^{(0)} x\)</span> and <span class="math notranslate nohighlight">\(S_J^{(1)} x\)</span>.</p>
<p>This class inherits from <cite>tf.keras.layers.Layer</cite>. As a result, it has
all the same capabilities as a standard Keras <cite>Layer</cite>.</p>
<p>Given an input <cite>tf.Tensor</cite> <cite>x</cite> of shape <cite>(B, N)</cite>, where <cite>B</cite> is the
number of signals to transform (the batch size) and <cite>N</cite> is the length
of the signal, we compute its scattering transform by passing it to
the <cite>scattering</cite> method (or calling the alias <cite>call</cite>). Note
that <cite>B</cite> can be one, in which case it may be omitted, giving an input
of shape <cite>(N,)</cite>.</p>
<p class="rubric">Example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set the parameters of the scattering transform.</span>
<span class="n">J</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">13</span>
<span class="n">Q</span> <span class="o">=</span> <span class="mi">8</span>

<span class="c1"># Generate a sample signal.</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

<span class="c1"># Define a Scattering1D object.</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">Scattering1D</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>

<span class="c1"># Calculate the scattering transform.</span>
<span class="n">Sx</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">scattering</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># Equivalently, use the alias.</span>
<span class="n">Sx</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>Above, the length of the signal is <span class="math notranslate nohighlight">\(N = 2^{13} = 8192\)</span>, while the
maximum scale of the scattering transform is set to <span class="math notranslate nohighlight">\(2^J = 2^6 =
64\)</span>. The time-frequency resolution of the first-order wavelets
<span class="math notranslate nohighlight">\(\psi_\lambda^{(1)}(t)\)</span> is set to <cite>Q = 8</cite> wavelets per octave.
The second-order wavelets <span class="math notranslate nohighlight">\(\psi_\mu^{(2)}(t)\)</span> always have one
wavelet per octave.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>J</strong> (<em>int</em>) – The maximum log-scale of the scattering transform. In other words,
the maximum scale is given by <span class="math notranslate nohighlight">\(2^J\)</span>.</p></li>
<li><p><strong>Q</strong> (<em>int</em><em> or </em><em>tuple</em>) – By default, Q (int) is the number of wavelets per octave for the first
order and that for the second order has one wavelet per octave. This
default value can be modified by passing Q as a tuple with two values,
i.e. Q = (Q1, Q2), where Q1 and Q2 are the number of wavelets per
octave for the first and second order, respectively.</p></li>
<li><p><strong>T</strong> (<em>int</em>) – temporal support of low-pass filter, controlling amount of imposed
time-shift invariance and maximum subsampling</p></li>
<li><p><strong>max_order</strong> (<em>int</em><em>, </em><em>optional</em>) – The maximum order of scattering coefficients to compute. Must be
either <cite>1</cite> or <cite>2</cite>. Defaults to <cite>2</cite>.</p></li>
<li><p><strong>oversampling</strong> (<em>integer &gt;= 0</em><em>, </em><em>optional</em>) – Controls the oversampling factor relative to the default as a
power of two. Since the convolving by wavelets (or lowpass
filters) and taking the modulus reduces the high-frequency content
of the signal, we can subsample to save space and improve
performance. However, this may reduce precision in the
calculation. If this is not desirable, <cite>oversampling</cite> can be set
to a large value to prevent too much subsampling. This parameter
may be modified after object creation. Defaults to <cite>0</cite>.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.keras.Scattering1D.J">
<span class="sig-name descname"><span class="pre">J</span></span><a class="headerlink" href="#kymatio.keras.Scattering1D.J" title="Permalink to this definition">¶</a></dt>
<dd><p>The maximum log-scale of the scattering transform. In other words,
the maximum scale is given by <cite>2 ** J</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.keras.Scattering1D.Q">
<span class="sig-name descname"><span class="pre">Q</span></span><a class="headerlink" href="#kymatio.keras.Scattering1D.Q" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of first-order wavelets per octave (second-order
wavelets are fixed to one wavelet per octave).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.keras.Scattering1D.T">
<span class="sig-name descname"><span class="pre">T</span></span><a class="headerlink" href="#kymatio.keras.Scattering1D.T" title="Permalink to this definition">¶</a></dt>
<dd><p>temporal support of low-pass filter, controlling amount of imposed
time-shift invariance and maximum subsampling</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.keras.Scattering1D.max_order">
<span class="sig-name descname"><span class="pre">max_order</span></span><a class="headerlink" href="#kymatio.keras.Scattering1D.max_order" title="Permalink to this definition">¶</a></dt>
<dd><p>The maximum scattering order of the transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.keras.Scattering1D.oversampling">
<span class="sig-name descname"><span class="pre">oversampling</span></span><a class="headerlink" href="#kymatio.keras.Scattering1D.oversampling" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of powers of two to oversample the output compared to
the default subsampling rate determined from the filters.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="kymatio.keras.Scattering1D.build">
<span class="sig-name descname"><span class="pre">build</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_shape</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kymatio.keras.Scattering1D.build" title="Permalink to this definition">¶</a></dt>
<dd><p>Set up padding and filters</p>
<p>Certain internal data, such as the amount of padding and the wavelet
filters to be used in the scattering transform, need to be computed
from the parameters given during construction. This function is called
automatically during object creation and no subsequent calls are
therefore needed.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="kymatio.keras.Scattering2D">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">kymatio.keras.</span></span><span class="sig-name descname"><span class="pre">Scattering2D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kymatio.keras.Scattering2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">ScatteringKeras</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ScatteringBase2D</span></code></p>
<p>The 2D scattering transform</p>
<p>The scattering transform computes two wavelet transform
followed by modulus non-linearity. It can be summarized as</p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\(S_J x = [S_J^{(0)} x, S_J^{(1)} x, S_J^{(2)} x]\)</span></p>
</div></blockquote>
<p>where</p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\(S_J^{(0)} x = x \star \phi_J\)</span>,</p>
<p><span class="math notranslate nohighlight">\(S_J^{(1)} x = [|x \star \psi^{(1)}_\lambda| \star \phi_J]_\lambda\)</span>, and</p>
<p><span class="math notranslate nohighlight">\(S_J^{(2)} x = [||x \star \psi^{(1)}_\lambda| \star
\psi^{(2)}_\mu| \star \phi_J]_{\lambda, \mu}\)</span>.</p>
</div></blockquote>
<p>where <span class="math notranslate nohighlight">\(\star\)</span> denotes the convolution (in space), <span class="math notranslate nohighlight">\(\phi_J\)</span> is a
lowpass filter, <span class="math notranslate nohighlight">\(\psi^{(1)}_\lambda\)</span> is a family of bandpass filters
and <span class="math notranslate nohighlight">\(\psi^{(2)}_\mu\)</span> is another family of bandpass filters. Only
Morlet filters are used in this implementation. Convolutions are
efficiently performed in the Fourier domain.</p>
<p>This class inherits from <cite>tf.keras.layers.Layer</cite>. As a result, it has
all the same capabilities as a standard Keras <cite>Layer</cite>.</p>
<p class="rubric">Example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set the parameters of the scattering transform.</span>
<span class="n">J</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">M</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span>

<span class="c1"># Generate a sample signal.</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>

<span class="c1"># Define a Scattering2D object.</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">Scattering2D</span><span class="p">(</span><span class="n">J</span><span class="p">)</span>

<span class="c1"># Calculate the scattering transform.</span>
<span class="n">Sx</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">scattering</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># Equivalently, use the alias.</span>
<span class="n">Sx</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>J</strong> (<em>int</em>) – Log-2 of the scattering scale.</p></li>
<li><p><strong>L</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of angles used for the wavelet transform. Defaults to <cite>8</cite>.</p></li>
<li><p><strong>max_order</strong> (<em>int</em><em>, </em><em>optional</em>) – The maximum order of scattering coefficients to compute. Must be
either <cite>1</cite> or <cite>2</cite>. Defaults to <cite>2</cite>.</p></li>
<li><p><strong>pre_pad</strong> (<em>boolean</em><em>, </em><em>optional</em>) – Controls the padding: if set to False, a symmetric padding is
applied on the signal. If set to True, the software will assume
the signal was padded externally. Defaults to <cite>False</cite>.</p></li>
<li><p><strong>backend</strong> (<em>object</em><em>, </em><em>optional</em>) – Controls the backend which is combined with the frontend.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.keras.Scattering2D.J">
<span class="sig-name descname"><span class="pre">J</span></span><a class="headerlink" href="#kymatio.keras.Scattering2D.J" title="Permalink to this definition">¶</a></dt>
<dd><p>Log-2 of the scattering scale.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.keras.Scattering2D.L">
<span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#kymatio.keras.Scattering2D.L" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of angles used for the wavelet transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int, optional</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.keras.Scattering2D.max_order">
<span class="sig-name descname"><span class="pre">max_order</span></span><a class="headerlink" href="#kymatio.keras.Scattering2D.max_order" title="Permalink to this definition">¶</a></dt>
<dd><p>The maximum order of scattering coefficients to compute.
Must be either <cite>1</cite> or <cite>2</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int, optional</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.keras.Scattering2D.pre_pad">
<span class="sig-name descname"><span class="pre">pre_pad</span></span><a class="headerlink" href="#kymatio.keras.Scattering2D.pre_pad" title="Permalink to this definition">¶</a></dt>
<dd><p>Controls the padding: if set to False, a symmetric padding is
applied on the signal. If set to True, the software will assume
the signal was padded externally.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>boolean</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Notes</p>
<p>The design of the filters is optimized for the value <cite>L = 8</cite>.</p>
<p>The <cite>pre_pad</cite> flag is particularly useful when cropping bigger images
because this does not introduce border effects inherent to padding.</p>
<dl class="py method">
<dt class="sig sig-object py" id="kymatio.keras.Scattering2D.build">
<span class="sig-name descname"><span class="pre">build</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_shape</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kymatio.keras.Scattering2D.build" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines elementary routines.</p>
<p>This function should always call and create the filters via
self.create_filters() defined below. For instance, via:
self.filters = self.create_filters()</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-kymatio.jax">
<span id="jax"></span><h2>Jax<a class="headerlink" href="#module-kymatio.jax" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="kymatio.jax.HarmonicScattering3D">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">kymatio.jax.</span></span><span class="sig-name descname"><span class="pre">HarmonicScattering3D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">J</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">L</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation_covariant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'integral'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">points</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integral_powers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0.5,</span> <span class="pre">1.0,</span> <span class="pre">2.0)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'jax'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kymatio.jax.HarmonicScattering3D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">ScatteringJax</span></code>, <a class="reference internal" href="#kymatio.numpy.HarmonicScattering3D" title="kymatio.numpy.HarmonicScatteringNumPy3D"><code class="xref py py-class docutils literal notranslate"><span class="pre">HarmonicScatteringNumPy3D</span></code></a></p>
<p>The 3D solid harmonic scattering transform</p>
<p>This class implements solid harmonic scattering on a 3D input image.
For details see <a class="reference external" href="https://arxiv.org/abs/1805.00571">https://arxiv.org/abs/1805.00571</a>.</p>
<p class="rubric">Example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set the parameters of the scattering transform.</span>
<span class="n">J</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">O</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span>

<span class="c1"># Generate a sample signal.</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">O</span><span class="p">)</span>

<span class="c1"># Define a HarmonicScattering3D object.</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">HarmonicScattering3D</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">O</span><span class="p">))</span>

<span class="c1"># Calculate the scattering transform.</span>
<span class="n">Sx</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">scattering</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># Equivalently, use the alias.</span>
<span class="n">Sx</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>J</strong> (<em>int</em>) – Number of scales.</p></li>
<li><p><strong>shape</strong> (<em>tuple of ints</em>) – Shape <cite>(M, N, O)</cite> of the input signal</p></li>
<li><p><strong>L</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of <cite>l</cite> values. Defaults to <cite>3</cite>.</p></li>
<li><p><strong>sigma_0</strong> (<em>float</em><em>, </em><em>optional</em>) – Bandwidth of mother wavelet. Defaults to <cite>1</cite>.</p></li>
<li><p><strong>max_order</strong> (<em>int</em><em>, </em><em>optional</em>) – The maximum order of scattering coefficients to compute. Must be
either <cite>1</cite> or <cite>2</cite>. Defaults to <cite>2</cite>.</p></li>
<li><p><strong>rotation_covariant</strong> (<em>bool</em><em>, </em><em>optional</em>) – <p>If set to <cite>True</cite> the first-order moduli take the form:</p>
<p><span class="math notranslate nohighlight">\(\sqrt{\sum_m (x \star \psi_{j,l,m})^2)}\)</span></p>
<p>if set to <cite>False</cite> the first-order moduli take the form:</p>
<p><span class="math notranslate nohighlight">\(x \star \psi_{j,l,m}\)</span></p>
<p>The second order moduli change analogously. Defaults to <cite>True</cite>.</p>
</p></li>
<li><p><strong>method</strong> (<em>string</em><em>, </em><em>optional</em>) – Specifies the method for obtaining scattering coefficients.
Currently, only <cite>‘integral’</cite> is available. Defaults to <cite>‘integral’</cite>.</p></li>
<li><p><strong>integral_powers</strong> (<em>array-like</em>) – List of exponents to the power of which moduli are raised before
integration.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="kymatio.jax.HarmonicScattering3D.build">
<span class="sig-name descname"><span class="pre">build</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#kymatio.jax.HarmonicScattering3D.build" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines elementary routines.</p>
<p>This function should always call and create the filters via
self.create_filters() defined below. For instance, via:
self.filters = self.create_filters()</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="kymatio.jax.Scattering1D">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">kymatio.jax.</span></span><span class="sig-name descname"><span class="pre">Scattering1D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">J</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">average</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">oversampling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'array'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'jax'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kymatio.jax.Scattering1D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">ScatteringJax</span></code>, <a class="reference internal" href="#kymatio.numpy.Scattering1D" title="kymatio.numpy.ScatteringNumPy1D"><code class="xref py py-class docutils literal notranslate"><span class="pre">ScatteringNumPy1D</span></code></a></p>
<p>The 1D scattering transform</p>
<blockquote>
<div><p>The scattering transform computes a cascade of wavelet transforms
alternated with a complex modulus non-linearity. The scattering
transform of a 1D signal <span class="math notranslate nohighlight">\(x(t)\)</span> may be written as</p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\(S_J x = [S_J^{(0)} x, S_J^{(1)} x, S_J^{(2)} x]\)</span></p>
</div></blockquote>
<p>where</p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\(S_J^{(0)} x(t) = x \star \phi_J(t)\)</span>,</p>
<p><span class="math notranslate nohighlight">\(S_J^{(1)} x(t, \lambda) = |x \star \psi_\lambda^{(1)}| \star \phi_J\)</span>, and</p>
<p><span class="math notranslate nohighlight">\(S_J^{(2)} x(t, \lambda, \mu) = |\,| x \star \psi_\lambda^{(1)}| \star \psi_\mu^{(2)} | \star \phi_J\)</span>.</p>
</div></blockquote>
<p>In the above formulas, <span class="math notranslate nohighlight">\(\star\)</span> denotes convolution in time. The
filters <span class="math notranslate nohighlight">\(\psi_\lambda^{(1)}(t)\)</span> and <span class="math notranslate nohighlight">\(\psi_\mu^{(2)}(t)\)</span> are analytic
wavelets with center frequencies <span class="math notranslate nohighlight">\(\lambda\)</span> and <span class="math notranslate nohighlight">\(\mu\)</span>, while
<span class="math notranslate nohighlight">\(\phi_J(t)\)</span> is a real lowpass filter centered at the zero frequency.</p>
<p>The <cite>Scattering1D</cite> class implements the 1D scattering transform for a
given set of filters whose parameters are specified at initialization.
While the wavelets are fixed, other parameters may be changed after
the object is created, such as whether to compute all of
<span class="math notranslate nohighlight">\(S_J^{(0)} x\)</span>, <span class="math notranslate nohighlight">\(S_J^{(1)} x\)</span>, and <span class="math notranslate nohighlight">\(S_J^{(2)} x\)</span> or just
<span class="math notranslate nohighlight">\(S_J^{(0)} x\)</span> and <span class="math notranslate nohighlight">\(S_J^{(1)} x\)</span>.</p>
<p>Given an input <cite>np.ndarray</cite> <cite>x</cite> of shape <cite>(B, N)</cite>, where <cite>B</cite> is the
number of signals to transform (the batch size) and <cite>N</cite> is the length
of the signal, we compute its scattering transform by passing it to
the <cite>scattering</cite> method (or calling the alias <cite>__call__</cite>). Note
that <cite>B</cite> can be one, in which case it may be omitted, giving an input
of shape <cite>(N,)</cite>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set the parameters of the scattering transform.</span>
<span class="n">J</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">13</span>
<span class="n">Q</span> <span class="o">=</span> <span class="mi">8</span>

<span class="c1"># Generate a sample signal.</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

<span class="c1"># Define a Scattering1D object.</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">Scattering1D</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>

<span class="c1"># Calculate the scattering transform.</span>
<span class="n">Sx</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">scattering</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># Equivalently, use the alias.</span>
<span class="n">Sx</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>Above, the length of the signal is <span class="math notranslate nohighlight">\(N = 2^{13} = 8192\)</span>, while the
maximum scale of the scattering transform is set to <span class="math notranslate nohighlight">\(2^J = 2^6 =
64\)</span>. The time-frequency resolution of the first-order wavelets
<span class="math notranslate nohighlight">\(\psi_\lambda^{(1)}(t)\)</span> is set to <cite>Q = 8</cite> wavelets per octave.
The second-order wavelets <span class="math notranslate nohighlight">\(\psi_\mu^{(2)}(t)\)</span> always have one
wavelet per octave.</p>
<dl class="simple">
<dt>J<span class="classifier">int</span></dt><dd><p>The maximum log-scale of the scattering transform. In other words,
the maximum scale is given by <span class="math notranslate nohighlight">\(2^J\)</span>.</p>
</dd>
<dt>shape<span class="classifier">int</span></dt><dd><p>The length of the input signals.</p>
</dd>
<dt>Q<span class="classifier">int or tuple</span></dt><dd><p>By default, Q (int) is the number of wavelets per octave for the first
order and that for the second order has one wavelet per octave. This
default value can be modified by passing Q as a tuple with two values,
i.e. Q = (Q1, Q2), where Q1 and Q2 are the number of wavelets per
octave for the first and second order, respectively.</p>
</dd>
<dt>T<span class="classifier">int</span></dt><dd><p>temporal support of low-pass filter, controlling amount of imposed
time-shift invariance and maximum subsampling</p>
</dd>
<dt>max_order<span class="classifier">int, optional</span></dt><dd><p>The maximum order of scattering coefficients to compute. Must be
either <cite>1</cite> or <cite>2</cite>. Defaults to <cite>2</cite>.</p>
</dd>
<dt>average<span class="classifier">boolean, optional</span></dt><dd><p>Determines whether the output is averaged in time or not. The
averaged output corresponds to the standard scattering transform,
while the un-averaged output skips the last convolution by
<span class="math notranslate nohighlight">\(\phi_J(t)\)</span>.  This parameter may be modified after object
creation. Defaults to <cite>True</cite>. Deprecated in v0.3 in favour of <cite>T</cite>
and will  be removed in v0.4. Replace <cite>average=False</cite> by <cite>T=0</cite> and
set <cite>T&gt;1</cite> or leave <cite>T=None</cite> for <cite>average=True</cite> (default).</p>
</dd>
<dt>oversampling<span class="classifier">integer &gt;= 0, optional</span></dt><dd><p>Controls the oversampling factor relative to the default as a
power of two. Since the convolving by wavelets (or lowpass
filters) and taking the modulus reduces the high-frequency content
of the signal, we can subsample to save space and improve
performance. However, this may reduce precision in the
calculation. If this is not desirable, <cite>oversampling</cite> can be set
to a large value to prevent too much subsampling. This parameter
may be modified after object creation. Defaults to <cite>0</cite>.</p>
</dd>
<dt>vectorize<span class="classifier">boolean, optional</span></dt><dd><p>Determines wheter to return a vectorized scattering transform
(that is, a large array containing the output) or a dictionary
(where each entry corresponds to a separate scattering
coefficient). This parameter may be modified after object
creation. Deprecated in favor of <cite>out_type</cite> (see below). Defaults
to True.</p>
</dd>
<dt>out_type<span class="classifier">str, optional</span></dt><dd><p>The format of the output of a scattering transform. If set to
<cite>‘list’</cite>, then the output is a list containing each individual
scattering coefficient with meta information. Otherwise, if set to
<cite>‘array’</cite>, the output is a large array containing the
concatenation of all scattering coefficients. Defaults to
<cite>‘array’</cite>.</p>
</dd>
</dl>
<dl class="simple">
<dt>J<span class="classifier">int</span></dt><dd><p>The maximum log-scale of the scattering transform. In other words,
the maximum scale is given by <cite>2 ** J</cite>.</p>
</dd>
<dt>shape<span class="classifier">int</span></dt><dd><p>The length of the input signals.</p>
</dd>
<dt>Q<span class="classifier">int</span></dt><dd><p>The number of first-order wavelets per octave (second-order
wavelets are fixed to one wavelet per octave).</p>
</dd>
<dt>T<span class="classifier">int</span></dt><dd><p>temporal support of low-pass filter, controlling amount of imposed
time-shift invariance and maximum subsampling</p>
</dd>
<dt>pad_left<span class="classifier">int</span></dt><dd><p>The amount of padding to the left of the signal.</p>
</dd>
<dt>pad_right<span class="classifier">int</span></dt><dd><p>The amount of padding to the right of the signal.</p>
</dd>
<dt>phi_f<span class="classifier">dictionary</span></dt><dd><p>A dictionary containing the lowpass filter at all resolutions. See
<cite>filter_bank.scattering_filter_factory</cite> for an exact description.</p>
</dd>
<dt>psi1_f<span class="classifier">dictionary</span></dt><dd><p>A dictionary containing all the first-order wavelet filters, each
represented as a dictionary containing that filter at all
resolutions. See <cite>filter_bank.scattering_filter_factory</cite> for an
exact description.</p>
</dd>
<dt>psi2_f<span class="classifier">dictionary</span></dt><dd><p>A dictionary containing all the second-order wavelet filters, each
represented as a dictionary containing that filter at all
resolutions. See <cite>filter_bank.scattering_filter_factory</cite> for an
exact description.</p>
</dd>
<dt>max_order<span class="classifier">int</span></dt><dd><p>The maximum scattering order of the transform.</p>
</dd>
<dt>average<span class="classifier">boolean</span></dt><dd><p>Controls whether the output should be averaged (the standard
scattering transform) or not (resulting in wavelet modulus
coefficients). Note that to obtain unaveraged output, the
<cite>vectorize</cite> flag must be set to <cite>False</cite> or <cite>out_type</cite> must be set
to <cite>‘list’</cite>. Deprecated in favor of <cite>T</cite>. For more details,
see the documentation for <cite>scattering</cite>.</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>oversampling<span class="classifier">int</span></dt><dd><blockquote>
<div><p>The number of powers of two to oversample the output compared to
the default subsampling rate determined from the filters.</p>
</div></blockquote>
<dl class="simple">
<dt>vectorize<span class="classifier">boolean</span></dt><dd><p>Controls whether the output should be vectorized into a single
Tensor or collected into a dictionary. Deprecated in favor of
<cite>out_type</cite>. For more details, see the documentation for
<cite>scattering</cite>.</p>
</dd>
<dt>out_type<span class="classifier">str</span></dt><dd><p>Specifices the output format of the transform, which is currently
one of <cite>‘array’</cite> or <cite>‘list</cite>’. If <cite>‘array’</cite>, the output is a large
array containing the scattering coefficients. If <cite>‘list</cite>’, the
output is a list of dictionaries, each containing a scattering
coefficient along with meta information. For more information, see
the documentation for <cite>scattering</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="kymatio.jax.Scattering2D">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">kymatio.jax.</span></span><span class="sig-name descname"><span class="pre">Scattering2D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">J</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">L</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_pad</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'jax'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'array'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kymatio.jax.Scattering2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">ScatteringJax</span></code>, <a class="reference internal" href="#kymatio.numpy.Scattering2D" title="kymatio.numpy.ScatteringNumPy2D"><code class="xref py py-class docutils literal notranslate"><span class="pre">ScatteringNumPy2D</span></code></a></p>
<p>The 2D scattering transform</p>
<p>The scattering transform computes two wavelet transform
followed by modulus non-linearity. It can be summarized as</p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\(S_J x = [S_J^{(0)} x, S_J^{(1)} x, S_J^{(2)} x]\)</span></p>
</div></blockquote>
<p>where</p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\(S_J^{(0)} x = x \star \phi_J\)</span>,</p>
<p><span class="math notranslate nohighlight">\(S_J^{(1)} x = [|x \star \psi^{(1)}_\lambda| \star \phi_J]_\lambda\)</span>, and</p>
<p><span class="math notranslate nohighlight">\(S_J^{(2)} x = [||x \star \psi^{(1)}_\lambda| \star
\psi^{(2)}_\mu| \star \phi_J]_{\lambda, \mu}\)</span>.</p>
</div></blockquote>
<p>where <span class="math notranslate nohighlight">\(\star\)</span> denotes the convolution (in space), <span class="math notranslate nohighlight">\(\phi_J\)</span> is a
lowpass filter, <span class="math notranslate nohighlight">\(\psi^{(1)}_\lambda\)</span> is a family of bandpass filters
and <span class="math notranslate nohighlight">\(\psi^{(2)}_\mu\)</span> is another family of bandpass filters. Only
Morlet filters are used in this implementation. Convolutions are
efficiently performed in the Fourier domain.</p>
<p class="rubric">Example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set the parameters of the scattering transform.</span>
<span class="n">J</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">M</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span>

<span class="c1"># Generate a sample signal.</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>

<span class="c1"># Define a Scattering2D object.</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">Scattering2D</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>

<span class="c1"># Calculate the scattering transform.</span>
<span class="n">Sx</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">scattering</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># Equivalently, use the alias.</span>
<span class="n">Sx</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>J</strong> (<em>int</em>) – Log-2 of the scattering scale.</p></li>
<li><p><strong>shape</strong> (<em>tuple of ints</em>) – Spatial support (M, N) of the input</p></li>
<li><p><strong>L</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of angles used for the wavelet transform. Defaults to <cite>8</cite>.</p></li>
<li><p><strong>max_order</strong> (<em>int</em><em>, </em><em>optional</em>) – The maximum order of scattering coefficients to compute. Must be
either <cite>1</cite> or <cite>2</cite>. Defaults to <cite>2</cite>.</p></li>
<li><p><strong>pre_pad</strong> (<em>boolean</em><em>, </em><em>optional</em>) – Controls the padding: if set to False, a symmetric padding is
applied on the signal. If set to True, the software will assume
the signal was padded externally. Defaults to <cite>False</cite>.</p></li>
<li><p><strong>backend</strong> (<em>object</em><em>, </em><em>optional</em>) – Controls the backend which is combined with the frontend.</p></li>
<li><p><strong>out_type</strong> (<em>str</em><em>, </em><em>optional</em>) – The format of the output of a scattering transform. If set to
<cite>‘list’</cite>, then the output is a list containing each individual
scattering path with meta information. Otherwise, if set to
<cite>‘array’</cite>, the output is a large array containing the
concatenation of all scattering coefficients. Defaults to
<cite>‘array’</cite>.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.jax.Scattering2D.J">
<span class="sig-name descname"><span class="pre">J</span></span><a class="headerlink" href="#kymatio.jax.Scattering2D.J" title="Permalink to this definition">¶</a></dt>
<dd><p>Log-2 of the scattering scale.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.jax.Scattering2D.shape">
<span class="sig-name descname"><span class="pre">shape</span></span><a class="headerlink" href="#kymatio.jax.Scattering2D.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Spatial support (M, N) of the input</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple of ints</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.jax.Scattering2D.L">
<span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#kymatio.jax.Scattering2D.L" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of angles used for the wavelet transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int, optional</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.jax.Scattering2D.max_order">
<span class="sig-name descname"><span class="pre">max_order</span></span><a class="headerlink" href="#kymatio.jax.Scattering2D.max_order" title="Permalink to this definition">¶</a></dt>
<dd><p>The maximum order of scattering coefficients to compute.
Must be either <cite>1</cite> or <cite>2</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int, optional</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.jax.Scattering2D.pre_pad">
<span class="sig-name descname"><span class="pre">pre_pad</span></span><a class="headerlink" href="#kymatio.jax.Scattering2D.pre_pad" title="Permalink to this definition">¶</a></dt>
<dd><p>Controls the padding: if set to False, a symmetric padding is
applied on the signal. If set to True, the software will assume
the signal was padded externally.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>boolean</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.jax.Scattering2D.Psi">
<span class="sig-name descname"><span class="pre">Psi</span></span><a class="headerlink" href="#kymatio.jax.Scattering2D.Psi" title="Permalink to this definition">¶</a></dt>
<dd><p>Contains the wavelets filters at all resolutions. See
<cite>filter_bank.filter_bank</cite> for an exact description.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.jax.Scattering2D.Phi">
<span class="sig-name descname"><span class="pre">Phi</span></span><a class="headerlink" href="#kymatio.jax.Scattering2D.Phi" title="Permalink to this definition">¶</a></dt>
<dd><p>Contains the low-pass filters at all resolutions. See
<cite>filter_bank.filter_bank</cite> for an exact description.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">M_padded,</span> <span class="pre">N_padded</span></span></dt>
<dd><p>Spatial support of the padded input.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kymatio.jax.Scattering2D.out_type">
<span class="sig-name descname"><span class="pre">out_type</span></span><a class="headerlink" href="#kymatio.jax.Scattering2D.out_type" title="Permalink to this definition">¶</a></dt>
<dd><p>The format of the scattering output. See documentation for
<cite>out_type</cite> parameter above and the documentation for <cite>scattering</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Notes</p>
<p>The design of the filters is optimized for the value <cite>L = 8</cite>.</p>
<p>The <cite>pre_pad</cite> flag is particularly useful when cropping bigger images
because this does not introduce border effects inherent to padding.</p>
</dd></dl>

</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="index.html">
    <img class="logo" src="_static/kymatio.jpg" alt="Logo"/>
    
  </a>
</p>



<p class="blurb">Wavelet Scattering in Python<br>&nbsp;&nbsp;&nbsp;<a href="https://twitter.com/KymatioWavelets"><img width="40px" src="https://avatars3.githubusercontent.com/u/50278?s=200&v=4"></a></p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=kymatio&repo=kymatio&type=star&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="userguide.html">User guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="developerguide.html">Information for developers</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-kymatio.numpy">NumPy</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-kymatio.sklearn">Scikit-learn</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-kymatio.torch">PyTorch</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-kymatio.tensorflow">TensorFlow</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-kymatio.keras">Keras</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-kymatio.jax">Jax</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="gallery_1d/index.html">1D examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="gallery_2d/index.html">2D examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="gallery_3d/index.html">3D examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="whats_new.html">What’s New</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="developerguide.html" title="previous chapter">Information for developers</a></li>
      <li>Next: <a href="gallery_1d/index.html" title="next chapter">1D examples</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018–2021, The Kymatio Developers.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.1.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/codereference.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    
    <a href="https://github.com/kymatio/kymatio" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    
    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-130785726-1']);
      _gaq.push(['_setDomainName', 'none']);
      _gaq.push(['_setAllowLinker', true]);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>
    
  </body>
</html>